"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[3549],{2586:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-2","title":"Chapter 2: Python Integration with rclpy","description":"This chapter focuses on implementing ROS 2 concepts using Python and the rclpy library. You\'ll learn how to create nodes, publish and subscribe to topics, implement services, and work with actions in Python.","source":"@site/docs/module-1-robotic-nervous-system/chapter-2.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-2","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/chapter-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"Chapter 2: Python Integration with rclpy","sidebar_position":2},"sidebar":"textbookSidebar","previous":{"title":"Chapter 1: ROS 2 Architecture","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-1"},"next":{"title":"Module 1: Robotic Nervous System (ROS 2)","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/"}}');var s=i(4848),t=i(8453);const o={sidebar_label:"Chapter 2: Python Integration with rclpy",sidebar_position:2},l="Chapter 2: Python Integration with rclpy",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Setting Up Your Environment",id:"setting-up-your-environment",level:2},{value:"Creating Your First ROS 2 Node",id:"creating-your-first-ros-2-node",level:2},{value:"Creating Subscribers",id:"creating-subscribers",level:2},{value:"Working with Services",id:"working-with-services",level:2},{value:"Working with Actions",id:"working-with-actions",level:2},{value:"Parameter Handling",id:"parameter-handling",level:2},{value:"Launch Files",id:"launch-files",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Code Organization",id:"code-organization",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-2-python-integration-with-rclpy",children:"Chapter 2: Python Integration with rclpy"})}),"\n",(0,s.jsxs)(n.p,{children:["This chapter focuses on implementing ROS 2 concepts using Python and the ",(0,s.jsx)(n.code,{children:"rclpy"})," library. You'll learn how to create nodes, publish and subscribe to topics, implement services, and work with actions in Python."]}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create ROS 2 nodes using Python and rclpy"}),"\n",(0,s.jsx)(n.li,{children:"Implement publishers and subscribers for message passing"}),"\n",(0,s.jsx)(n.li,{children:"Create and use services for request-response communication"}),"\n",(0,s.jsx)(n.li,{children:"Work with actions for long-running operations"}),"\n",(0,s.jsx)(n.li,{children:"Structure Python code following ROS 2 best practices"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rclpy"})," is the Python client library for ROS 2. It provides Python APIs that are conceptually similar to the underlying ROS client library implementations (rcl). Using ",(0,s.jsx)(n.code,{children:"rclpy"}),", you can create ROS 2 nodes, publish and subscribe to topics, provide and use services, and create and use actions."]}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-your-environment",children:"Setting Up Your Environment"}),"\n",(0,s.jsx)(n.p,{children:"Before writing ROS 2 Python code, ensure your environment is properly configured:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"source /opt/ros/humble/setup.bash\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-your-first-ros-2-node",children:"Creating Your First ROS 2 Node"}),"\n",(0,s.jsx)(n.p,{children:"Let's start by creating a simple ROS 2 node in Python:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    minimal_publisher = MinimalPublisher()\n\n    rclpy.spin(minimal_publisher)\n\n    # Destroy the node explicitly\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-subscribers",children:"Creating Subscribers"}),"\n",(0,s.jsx)(n.p,{children:"To create a subscriber that receives messages:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    minimal_subscriber = MinimalSubscriber()\n\n    rclpy.spin(minimal_subscriber)\n\n    # Destroy the node explicitly\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"working-with-services",children:"Working with Services"}),"\n",(0,s.jsx)(n.p,{children:"Creating a service server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info('Incoming request\\na: %d b: %d' % (request.a, request.b))\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    minimal_service = MinimalService()\n\n    rclpy.spin(minimal_service)\n\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Creating a service client:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import sys\nfrom example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalClientAsync(Node):\n\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    minimal_client = MinimalClientAsync()\n    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))\n    minimal_client.get_logger().info(\n        'Result of add_two_ints: for %d + %d = %d' %\n        (int(sys.argv[1]), int(sys.argv[2]), response.sum))\n\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"working-with-actions",children:"Working with Actions"}),"\n",(0,s.jsx)(n.p,{children:"Creating an action server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Publishing feedback: {feedback_msg.sequence}')\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Returning result: {result.sequence}')\n\n        return result\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 nodes can accept parameters that can be configured at runtime:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass ParameterNode(Node):\n\n    def __init__(self):\n        super().__init__('parameter_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('my_parameter', 'default_value')\n\n        # Get parameter value\n        my_param = self.get_parameter('my_parameter').value\n        self.get_logger().info(f'My parameter is: {my_param}')\n"})}),"\n",(0,s.jsx)(n.h2,{id:"launch-files",children:"Launch Files"}),"\n",(0,s.jsx)(n.p,{children:"Launch files allow you to start multiple nodes at once with specific configurations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<launch>\n  <node pkg="my_package" exec="minimal_publisher" name="publisher" output="screen">\n    <param name="my_parameter" value="custom_value"/>\n  </node>\n  <node pkg="my_package" exec="minimal_subscriber" name="subscriber" output="screen"/>\n</launch>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Node Structure"}),": Organize your node as a class that inherits from ",(0,s.jsx)(n.code,{children:"rclpy.node.Node"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Management"}),": Always call ",(0,s.jsx)(n.code,{children:"destroy_node()"})," when shutting down"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logging"}),": Use ",(0,s.jsx)(n.code,{children:"self.get_logger().info()"})," for debugging and status messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Implement proper error handling for network and communication issues"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameter Validation"}),": Validate parameters at startup to ensure configuration is correct"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-organization",children:"Code Organization"}),"\n",(0,s.jsx)(n.p,{children:"Structure your ROS 2 Python packages following these conventions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my_robot_package/\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 resource/\n\u2502   \u2514\u2500\u2500 my_robot_package\n\u251c\u2500\u2500 my_robot_package/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 nodes/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 publisher_node.py\n\u2502   \u2502   \u2514\u2500\u2500 subscriber_node.py\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 helper_functions.py\n\u2514\u2500\u2500 launch/\n    \u2514\u2500\u2500 my_launch_file.launch.py\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This chapter provided a comprehensive introduction to implementing ROS 2 concepts in Python using rclpy. You've learned how to create nodes, implement different communication patterns, handle parameters, and structure your code following best practices."}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implementation Exercise"}),": Create a ROS 2 node that publishes sensor data (simulated IMU readings) and another node that subscribes to this data and logs it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Exercise"}),": Implement a service that calculates the distance between two points in 2D space, with the node that provides the service and a client that calls it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Architecture Exercise"}),": Design and implement a simple robot controller with separate nodes for sensor processing, path planning, and motor control, all communicating through ROS 2 topics."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"In the next section, we'll explore URDF (Unified Robot Description Format) for modeling humanoid robots, building on the communication foundation established in this chapter."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);