"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[6714],{5163:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-5","title":"Chapter 5: Sensor-Actuator-Control Pipelines","description":"This chapter explores the integration of sensors, actuators, and control systems in ROS 2, forming the complete feedback loops necessary for autonomous robot operation. You\'ll learn how to create sensor-actuator-control pipelines that enable robots to perceive their environment, make decisions, and execute actions.","source":"@site/docs/module-1-robotic-nervous-system/chapter-5.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-5","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/chapter-5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"Chapter 5: Sensor-Actuator-Control Pipelines","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"Chapter 4: URDF Modeling for Humanoids","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-4"},"next":{"title":"Exercises","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/exercises"}}');var s=t(4848),r=t(8453);const i={sidebar_label:"Chapter 5: Sensor-Actuator-Control Pipelines",sidebar_position:5},l="Chapter 5: Sensor-Actuator-Control Pipelines",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Sensor-Actuator-Controller Architecture",id:"introduction-to-sensor-actuator-controller-architecture",level:2},{value:"Sensor Types and Integration",id:"sensor-types-and-integration",level:2},{value:"Joint Position Sensors (Encoders)",id:"joint-position-sensors-encoders",level:3},{value:"IMU (Inertial Measurement Unit) Sensors",id:"imu-inertial-measurement-unit-sensors",level:3},{value:"Camera and Vision Sensors",id:"camera-and-vision-sensors",level:3},{value:"Control System Implementation",id:"control-system-implementation",level:2},{value:"PID Controller Example",id:"pid-controller-example",level:3},{value:"Joint Controller Node",id:"joint-controller-node",level:3},{value:"Safety and Error Handling",id:"safety-and-error-handling",level:2},{value:"Safety Monitor Node",id:"safety-monitor-node",level:3},{value:"Complete Pipeline Integration",id:"complete-pipeline-integration",level:2},{value:"Launch File for Complete Pipeline",id:"launch-file-for-complete-pipeline",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Real-Time Considerations",id:"real-time-considerations",level:3},{value:"Safety First",id:"safety-first",level:3},{value:"Modularity",id:"modularity",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-5-sensor-actuator-control-pipelines",children:"Chapter 5: Sensor-Actuator-Control Pipelines"})}),"\n",(0,s.jsx)(n.p,{children:"This chapter explores the integration of sensors, actuators, and control systems in ROS 2, forming the complete feedback loops necessary for autonomous robot operation. You'll learn how to create sensor-actuator-control pipelines that enable robots to perceive their environment, make decisions, and execute actions."}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Design sensor-actuator feedback loops for robotic systems"}),"\n",(0,s.jsx)(n.li,{children:"Implement control pipelines that process sensor data and command actuators"}),"\n",(0,s.jsx)(n.li,{children:"Integrate various sensor types (IMU, encoders, cameras, LiDAR) into control systems"}),"\n",(0,s.jsx)(n.li,{children:"Implement safety mechanisms and error handling in control pipelines"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-sensor-actuator-controller-architecture",children:"Introduction to Sensor-Actuator-Controller Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The sensor-actuator-control pipeline forms the foundation of autonomous robotic systems. It creates a feedback loop where sensors provide information about the robot's state and environment, controllers process this information to make decisions, and actuators execute the resulting commands."}),"\n",(0,s.jsx)(n.p,{children:"The typical pipeline follows this pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Sensors \u2192 Sensor Processing \u2192 State Estimation \u2192 Controller \u2192 Actuator Commands \u2192 Actuators \u2192 Robot \u2192 Environment \u2192 Sensors (feedback)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-types-and-integration",children:"Sensor Types and Integration"}),"\n",(0,s.jsx)(n.h3,{id:"joint-position-sensors-encoders",children:"Joint Position Sensors (Encoders)"}),"\n",(0,s.jsx)(n.p,{children:"Joint position sensors provide feedback about the current position of robot joints:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport math\n\nclass JointStateProcessor(Node):\n    def __init__(self):\n        super().__init__('joint_state_processor')\n\n        # Subscribe to joint states\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Publisher for processed joint data\n        self.joint_pub = self.create_publisher(JointState, 'processed_joint_states', 10)\n\n        # Store previous joint states for velocity calculation\n        self.prev_positions = {}\n        self.prev_times = {}\n\n        self.get_logger().info('Joint State Processor initialized')\n\n    def joint_state_callback(self, msg):\n        current_time = self.get_clock().now().nanoseconds / 1e9\n\n        processed_msg = JointState()\n        processed_msg.header = msg.header\n        processed_msg.name = msg.name\n        processed_msg.position = msg.position\n        processed_msg.velocity = []\n        processed_msg.effort = msg.effort\n\n        # Calculate velocities from position changes\n        for i, (name, pos) in enumerate(zip(msg.name, msg.position)):\n            if name in self.prev_positions:\n                dt = current_time - self.prev_times[name]\n                if dt > 0:\n                    vel = (pos - self.prev_positions[name]) / dt\n                    processed_msg.velocity.append(vel)\n                else:\n                    processed_msg.velocity.append(0.0)\n            else:\n                processed_msg.velocity.append(0.0)\n\n            # Update stored values\n            self.prev_positions[name] = pos\n            self.prev_times[name] = current_time\n\n        # Publish processed joint states\n        self.joint_pub.publish(processed_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    processor = JointStateProcessor()\n    rclpy.spin(processor)\n    processor.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"imu-inertial-measurement-unit-sensors",children:"IMU (Inertial Measurement Unit) Sensors"}),"\n",(0,s.jsx)(n.p,{children:"IMU sensors provide orientation, angular velocity, and linear acceleration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import Vector3\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass ImuProcessor(Node):\n    def __init__(self):\n        super().__init__('imu_processor')\n\n        # Subscribe to IMU data\n        self.subscription = self.create_subscription(\n            Imu,\n            'imu/data',\n            self.imu_callback,\n            10\n        )\n\n        # Publisher for processed orientation\n        self.orientation_pub = self.create_publisher(Vector3, 'robot_orientation', 10)\n\n        # Store previous data for filtering\n        self.prev_orientation = None\n        self.orientation_history = []\n\n        self.get_logger().info('IMU Processor initialized')\n\n    def imu_callback(self, msg):\n        # Extract quaternion from IMU message\n        quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]\n\n        # Convert to Euler angles (roll, pitch, yaw)\n        rotation = R.from_quat(quat)\n        euler = rotation.as_euler('xyz', degrees=True)\n\n        # Create Vector3 message with Euler angles\n        orientation_msg = Vector3()\n        orientation_msg.x = euler[0]  # roll\n        orientation_msg.y = euler[1]  # pitch\n        orientation_msg.z = euler[2]  # yaw\n\n        # Publish processed orientation\n        self.orientation_pub.publish(orientation_msg)\n\n        # Store for filtering if needed\n        self.orientation_history.append(euler)\n        if len(self.orientation_history) > 10:\n            self.orientation_history.pop(0)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    processor = ImuProcessor()\n    rclpy.spin(processor)\n    processor.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"camera-and-vision-sensors",children:"Camera and Vision Sensors"}),"\n",(0,s.jsx)(n.p,{children:"Camera sensors provide visual information for perception:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport cv2\nimport numpy as np\n\nclass VisionProcessor(Node):\n    def __init__(self):\n        super().__init__('vision_processor')\n\n        # Create OpenCV bridge\n        self.bridge = CvBridge()\n\n        # Subscribe to camera feed\n        self.subscription = self.create_subscription(\n            Image,\n            'camera/image_raw',\n            self.image_callback,\n            10\n        )\n\n        # Publisher for processed image\n        self.processed_pub = self.create_publisher(Image, 'camera/image_processed', 10)\n\n        self.get_logger().info('Vision Processor initialized')\n\n    def image_callback(self, msg):\n        try:\n            # Convert ROS Image message to OpenCV image\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n            # Process the image (example: edge detection)\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n            edges = cv2.Canny(gray, 50, 150)\n\n            # Convert back to ROS Image message\n            processed_msg = self.bridge.cv2_to_imgmsg(edges, encoding='mono8')\n            processed_msg.header = msg.header\n\n            # Publish processed image\n            self.processed_pub.publish(processed_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing image: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    processor = VisionProcessor()\n    rclpy.spin(processor)\n    processor.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"control-system-implementation",children:"Control System Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"pid-controller-example",children:"PID Controller Example"}),"\n",(0,s.jsx)(n.p,{children:"A PID (Proportional-Integral-Derivative) controller is fundamental for precise control:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class PIDController:\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, min_output=-1.0, max_output=1.0):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.min_output = min_output\n        self.max_output = max_output\n\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.prev_time = None\n\n    def compute(self, setpoint, current_value, dt=None):\n        current_time = time.time()\n\n        if dt is None and self.prev_time is not None:\n            dt = current_time - self.prev_time\n        elif dt is None:\n            dt = 0.01  # Default time step\n\n        # Calculate error\n        error = setpoint - current_value\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        if dt > 0:\n            derivative = (error - self.prev_error) / dt\n        else:\n            derivative = 0.0\n        d_term = self.kd * derivative\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        # Clamp output to limits\n        output = max(self.min_output, min(self.max_output, output))\n\n        # Store values for next iteration\n        self.prev_error = error\n        self.prev_time = current_time\n\n        return output\n"})}),"\n",(0,s.jsx)(n.h3,{id:"joint-controller-node",children:"Joint Controller Node"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete joint controller that integrates sensor feedback with actuator commands:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\n\nclass JointController(Node):\n    def __init__(self):\n        super().__init__('joint_controller')\n\n        # Controller parameters\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\n        ]\n\n        # PID controllers for each joint\n        self.pid_controllers = {}\n        for joint_name in self.joint_names:\n            self.pid_controllers[joint_name] = PIDController(\n                kp=2.0, ki=0.1, kd=0.05,\n                min_output=-10.0, max_output=10.0\n            )\n\n        # Current joint states\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\n\n        # Target positions (initially current positions)\n        self.target_positions = self.current_positions.copy()\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Publishers\n        self.command_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_group_position_controller/commands',\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100Hz\n\n        self.get_logger().info('Joint Controller initialized')\n\n    def joint_state_callback(self, msg):\n        # Update current joint states\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\n            if name in self.current_positions:\n                self.current_positions[name] = pos\n                self.current_velocities[name] = vel\n\n    def control_loop(self):\n        # Calculate control commands for each joint\n        commands = []\n\n        for joint_name in self.joint_names:\n            current_pos = self.current_positions[joint_name]\n            target_pos = self.target_positions[joint_name]\n\n            # Compute control effort using PID\n            effort = self.pid_controllers[joint_name].compute(\n                target_pos, current_pos\n            )\n\n            commands.append(effort)\n\n        # Publish commands\n        command_msg = Float64MultiArray()\n        command_msg.data = commands\n        self.command_pub.publish(command_msg)\n\n    def set_target_positions(self, positions_dict):\n        \"\"\"Set target positions for joints\"\"\"\n        for joint_name, target_pos in positions_dict.items():\n            if joint_name in self.target_positions:\n                self.target_positions[joint_name] = target_pos\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = JointController()\n\n    # Example: Set a target position after startup\n    def set_initial_target():\n        controller.set_target_positions({\n            'left_hip_joint': 0.1,\n            'right_hip_joint': 0.1\n        })\n\n    # Schedule initial target after a short delay\n    timer = controller.create_timer(1.0, set_initial_target)\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"safety-and-error-handling",children:"Safety and Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"safety-monitor-node",children:"Safety Monitor Node"}),"\n",(0,s.jsx)(n.p,{children:"A safety monitor watches the system and implements safety mechanisms:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import Bool\nimport numpy as np\n\nclass SafetyMonitor(Node):\n    def __init__(self):\n        super().__init__('safety_monitor')\n\n        # Safety parameters\n        self.joint_limits = {\n            'left_hip_joint': (-1.5, 1.5),\n            'left_knee_joint': (0.0, 2.5),\n            'left_ankle_joint': (-0.5, 0.5),\n            'right_hip_joint': (-1.5, 1.5),\n            'right_knee_joint': (0.0, 2.5),\n            'right_ankle_joint': (-0.5, 0.5)\n        }\n\n        self.max_velocity = 5.0  # rad/s\n        self.max_tilt = 0.5  # rad (about 28 degrees)\n\n        # Safety state\n        self.emergency_stop = False\n        self.safety_violation = False\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            'imu/data',\n            self.imu_callback,\n            10\n        )\n\n        # Publisher for safety state\n        self.safety_pub = self.create_publisher(Bool, 'safety_status', 10)\n\n        # Timer for safety checks\n        self.safety_timer = self.create_timer(0.1, self.safety_check)  # 10Hz\n\n        self.get_logger().info('Safety Monitor initialized')\n\n    def joint_state_callback(self, msg):\n        if self.emergency_stop:\n            return\n\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\n            if name in self.joint_limits:\n                # Check position limits\n                min_limit, max_limit = self.joint_limits[name]\n                if pos < min_limit or pos > max_limit:\n                    self.safety_violation = True\n                    self.get_logger().error(f'Joint {name} exceeded position limits: {pos}')\n                    self.trigger_emergency_stop()\n                    return\n\n                # Check velocity limits\n                if abs(vel) > self.max_velocity:\n                    self.safety_violation = True\n                    self.get_logger().error(f'Joint {name} exceeded velocity limits: {vel}')\n                    self.trigger_emergency_stop()\n                    return\n\n    def imu_callback(self, msg):\n        if self.emergency_stop:\n            return\n\n        # Extract orientation from IMU\n        quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]\n\n        # Convert to Euler angles\n        from scipy.spatial.transform import Rotation as R\n        rotation = R.from_quat(quat)\n        euler = rotation.as_euler('xyz')\n\n        # Check tilt angles\n        roll, pitch, yaw = euler\n        if abs(roll) > self.max_tilt or abs(pitch) > self.max_tilt:\n            self.safety_violation = True\n            self.get_logger().error(f'Robot exceeded tilt limits: roll={roll:.2f}, pitch={pitch:.2f}')\n            self.trigger_emergency_stop()\n            return\n\n    def safety_check(self):\n        # Publish current safety status\n        safety_msg = Bool()\n        safety_msg.data = not self.emergency_stop\n        self.safety_pub.publish(safety_msg)\n\n    def trigger_emergency_stop(self):\n        self.emergency_stop = True\n        self.get_logger().error('EMERGENCY STOP TRIGGERED - Safety violation detected!')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    monitor = SafetyMonitor()\n    rclpy.spin(monitor)\n    monitor.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"complete-pipeline-integration",children:"Complete Pipeline Integration"}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of how to integrate all components into a complete sensor-actuator-control pipeline:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import Float64MultiArray, Bool\nimport numpy as np\n\nclass CompleteControlPipeline(Node):\n    def __init__(self):\n        super().__init__('complete_control_pipeline')\n\n        # Control state\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\n        ]\n\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\n        self.target_positions = {name: 0.0 for name in self.joint_names}\n\n        # PID controllers\n        self.pid_controllers = {}\n        for name in self.joint_names:\n            self.pid_controllers[name] = PIDController(\n                kp=2.0, ki=0.1, kd=0.05,\n                min_output=-10.0, max_output=10.0\n            )\n\n        # Safety state\n        self.safety_enabled = True\n        self.emergency_stop = False\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            'imu/data',\n            self.imu_callback,\n            10\n        )\n\n        self.safety_sub = self.create_subscription(\n            Bool,\n            'safety_status',\n            self.safety_callback,\n            10\n        )\n\n        # Publishers\n        self.command_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_group_position_controller/commands',\n            10\n        )\n\n        # Control timer\n        self.control_timer = self.create_timer(0.01, self.control_loop)\n\n        self.get_logger().info('Complete Control Pipeline initialized')\n\n    def joint_state_callback(self, msg):\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\n            if name in self.current_positions:\n                self.current_positions[name] = pos\n                self.current_velocities[name] = vel\n\n    def imu_callback(self, msg):\n        # Process IMU data if needed for control\n        pass\n\n    def safety_callback(self, msg):\n        self.safety_enabled = msg.data\n\n    def control_loop(self):\n        if not self.safety_enabled or self.emergency_stop:\n            # Send zero commands during safety stop\n            zero_commands = [0.0] * len(self.joint_names)\n            command_msg = Float64MultiArray()\n            command_msg.data = zero_commands\n            self.command_pub.publish(command_msg)\n            return\n\n        # Calculate control commands\n        commands = []\n        for name in self.joint_names:\n            current_pos = self.current_positions[name]\n            target_pos = self.target_positions[name]\n\n            effort = self.pid_controllers[name].compute(target_pos, current_pos)\n            commands.append(effort)\n\n        # Publish commands\n        command_msg = Float64MultiArray()\n        command_msg.data = commands\n        self.command_pub.publish(command_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    pipeline = CompleteControlPipeline()\n    rclpy.spin(pipeline)\n    pipeline.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"launch-file-for-complete-pipeline",children:"Launch File for Complete Pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["Create ",(0,s.jsx)(n.code,{children:"launch/sensor_actuator_pipeline_launch.py"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Joint state publisher (simulated robot)\n        Node(\n            package='joint_state_publisher',\n            executable='joint_state_publisher',\n            name='joint_state_publisher',\n            parameters=[{'use_sim_time': True}]\n        ),\n\n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            parameters=[{'use_sim_time': True}]\n        ),\n\n        # Sensor processors\n        Node(\n            package='my_robot_control',\n            executable='joint_state_processor',\n            name='joint_state_processor',\n            output='screen'\n        ),\n\n        Node(\n            package='my_robot_control',\n            executable='imu_processor',\n            name='imu_processor',\n            output='screen'\n        ),\n\n        Node(\n            package='my_robot_control',\n            executable='vision_processor',\n            name='vision_processor',\n            output='screen'\n        ),\n\n        # Controllers\n        Node(\n            package='my_robot_control',\n            executable='joint_controller',\n            name='joint_controller',\n            output='screen'\n        ),\n\n        # Safety monitor\n        Node(\n            package='my_robot_control',\n            executable='safety_monitor',\n            name='safety_monitor',\n            output='screen'\n        ),\n\n        # Complete pipeline\n        Node(\n            package='my_robot_control',\n            executable='complete_control_pipeline',\n            name='complete_control_pipeline',\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-considerations",children:"Real-Time Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use appropriate control frequencies (typically 100Hz for joint control)"}),"\n",(0,s.jsx)(n.li,{children:"Minimize computational complexity in control loops"}),"\n",(0,s.jsx)(n.li,{children:"Use efficient data structures and algorithms"}),"\n",(0,s.jsx)(n.li,{children:"Consider thread safety for concurrent access"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"safety-first",children:"Safety First"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always implement emergency stop functionality"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate limits for positions, velocities, and efforts"}),"\n",(0,s.jsx)(n.li,{children:"Monitor for safety violations continuously"}),"\n",(0,s.jsx)(n.li,{children:"Design fail-safe behaviors"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"modularity",children:"Modularity"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Separate sensor processing, control, and actuation logic"}),"\n",(0,s.jsx)(n.li,{children:"Use ROS 2's composability features when appropriate"}),"\n",(0,s.jsx)(n.li,{children:"Design nodes to be reusable across different robots"}),"\n",(0,s.jsx)(n.li,{children:"Follow ROS 2 design patterns and conventions"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Sensor-actuator-control pipelines form the backbone of autonomous robotic systems. By properly integrating sensors, controllers, and actuators with appropriate safety mechanisms, you can create robust systems that operate reliably in real-world conditions."}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pipeline Exercise"}),": Create a complete sensor-actuator-control pipeline for a simple mobile robot with wheel encoders and motor controllers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Exercise"}),": Implement additional safety checks for a humanoid robot, including collision detection and joint torque limits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Exercise"}),": Design a launch file that starts all components of your sensor-actuator-control pipeline and test it with a simulated robot."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"With the foundational ROS 2 concepts, launch files, URDF modeling, and sensor-actuator pipelines covered, you're ready to work on the Module 1 mini-project: building a complete ROS 2 control stack. This will integrate all the concepts learned in this module into a functional system."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var o=t(6540);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);