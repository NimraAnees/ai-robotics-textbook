"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[3354],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},9375:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-robotic-nervous-system/mini-project","title":"Mini-Project: ROS 2 Control Stack","description":"This mini-project brings together all the concepts from Module 1 to build a complete ROS 2 control stack for a simulated humanoid robot. You\'ll implement a distributed system with multiple nodes that communicate to control the robot\'s movements.","source":"@site/docs/module-1-robotic-nervous-system/mini-project.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/mini-project","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/mini-project","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/mini-project.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Mini-Project: ROS 2 Control Stack","sidebar_position":3},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Launch Files and Parameters","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-3"},"next":{"title":"Chapter 4: URDF Modeling for Humanoids","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-4"}}');var i=t(4848),s=t(8453);const r={sidebar_label:"Mini-Project: ROS 2 Control Stack",sidebar_position:3},l="Mini-Project: ROS 2 Control Stack",a={},c=[{value:"Project Overview",id:"project-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"1. Joint State Publisher Node",id:"1-joint-state-publisher-node",level:3},{value:"2. Trajectory Controller Node",id:"2-trajectory-controller-node",level:3},{value:"3. Command Interface Node",id:"3-command-interface-node",level:3},{value:"4. Feedback Monitor Node",id:"4-feedback-monitor-node",level:3},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set Up Package Structure",id:"step-1-set-up-package-structure",level:3},{value:"Step 2: Implement Joint State Publisher",id:"step-2-implement-joint-state-publisher",level:3},{value:"Step 3: Implement Trajectory Controller",id:"step-3-implement-trajectory-controller",level:3},{value:"Step 4: Implement Command Interface",id:"step-4-implement-command-interface",level:3},{value:"Step 5: Create Setup File",id:"step-5-create-setup-file",level:3},{value:"Step 6: Create Launch File",id:"step-6-create-launch-file",level:3},{value:"Testing Your Implementation",id:"testing-your-implementation",level:2},{value:"Project Deliverables",id:"project-deliverables",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2},{value:"Extension Challenges",id:"extension-challenges",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mini-project-ros-2-control-stack",children:"Mini-Project: ROS 2 Control Stack"})}),"\n",(0,i.jsx)(n.p,{children:"This mini-project brings together all the concepts from Module 1 to build a complete ROS 2 control stack for a simulated humanoid robot. You'll implement a distributed system with multiple nodes that communicate to control the robot's movements."}),"\n",(0,i.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,i.jsx)(n.p,{children:"Your task is to create a ROS 2 control stack that allows you to command a simulated humanoid robot to move its joints to specific positions. The system will include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A joint state publisher node"}),"\n",(0,i.jsx)(n.li,{children:"A trajectory controller node"}),"\n",(0,i.jsx)(n.li,{children:"A command interface node"}),"\n",(0,i.jsx)(n.li,{children:"A feedback monitoring node"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"Upon completion of this project, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design and implement a complete ROS 2 control system"}),"\n",(0,i.jsx)(n.li,{children:"Integrate multiple nodes with different responsibilities"}),"\n",(0,i.jsx)(n.li,{children:"Use ROS 2 messages, services, and parameters effectively"}),"\n",(0,i.jsx)(n.li,{children:"Test and validate your control system in simulation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The control stack will consist of the following nodes:"}),"\n",(0,i.jsx)(n.h3,{id:"1-joint-state-publisher-node",children:"1. Joint State Publisher Node"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Publishes current joint states using ",(0,i.jsx)(n.code,{children:"sensor_msgs/JointState"})," messages"]}),"\n",(0,i.jsx)(n.li,{children:"Simulates joint positions, velocities, and efforts"}),"\n",(0,i.jsxs)(n.li,{children:["Publishes robot description via ",(0,i.jsx)(n.code,{children:"/robot_description"})," parameter"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-trajectory-controller-node",children:"2. Trajectory Controller Node"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Subscribes to trajectory commands via ",(0,i.jsx)(n.code,{children:"trajectory_msgs/JointTrajectory"})," messages"]}),"\n",(0,i.jsx)(n.li,{children:"Implements simple joint interpolation"}),"\n",(0,i.jsx)(n.li,{children:"Publishes feedback on execution status"}),"\n",(0,i.jsx)(n.li,{children:"Uses services for configuration and control commands"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-command-interface-node",children:"3. Command Interface Node"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Provides a simple interface for sending trajectory commands"}),"\n",(0,i.jsx)(n.li,{children:"Subscribes to user commands (keyboard, GUI, or service calls)"}),"\n",(0,i.jsx)(n.li,{children:"Formats and sends trajectory messages to the controller"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-feedback-monitor-node",children:"4. Feedback Monitor Node"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Subscribes to joint states and controller feedback"}),"\n",(0,i.jsx)(n.li,{children:"Provides visualization of robot status"}),"\n",(0,i.jsx)(n.li,{children:"Logs execution metrics and errors"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-set-up-package-structure",children:"Step 1: Set Up Package Structure"}),"\n",(0,i.jsx)(n.p,{children:"Create a ROS 2 package for your control stack:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/humanoid_control_stack/src\ncd ~/ros2_ws/src/humanoid_control_stack\n"})}),"\n",(0,i.jsx)(n.p,{children:"Create the package.xml file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>humanoid_control_stack</name>\n  <version>0.0.1</version>\n  <description>ROS 2 Control Stack for Humanoid Robot</description>\n  <maintainer email="student@university.edu">Student</maintainer>\n  <license>MIT</license>\n\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n  <depend>sensor_msgs</depend>\n  <depend>trajectory_msgs</end>\n  <depend>builtin_interfaces</depend>\n\n  <exec_depend>python3-numpy</exec_depend>\n\n  <test_depend>ament_copyright</test_depend>\n  <test_depend>ament_flake8</test_depend>\n  <test_depend>ament_pep257</test_depend>\n  <test_depend>python3-pytest</test_depend>\n\n  <export>\n    <build_type>ament_python</build_type>\n  </export>\n</package>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-implement-joint-state-publisher",children:"Step 2: Implement Joint State Publisher"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/joint_state_publisher.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport math\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n\n        # Publisher for joint states\n        self.joint_state_publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Timer for publishing joint states at 50Hz\n        self.timer = self.create_timer(0.02, self.publish_joint_states)\n\n        # Initialize joint positions (simulated humanoid)\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\n            'head_pan_joint', 'head_tilt_joint'\n        ]\n\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_efforts = [0.0] * len(self.joint_names)\n\n        self.get_logger().info('Joint State Publisher initialized')\n\n    def publish_joint_states(self):\n        # Create joint state message\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n\n        # Publish the message\n        self.joint_state_publisher.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointStatePublisher()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-implement-trajectory-controller",children:"Step 3: Implement Trajectory Controller"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/trajectory_controller.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom sensor_msgs.msg import JointState\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nclass TrajectoryController(Node):\n    def __init__(self):\n        super().__init__('trajectory_controller')\n\n        # Subscriber for trajectory commands\n        self.trajectory_sub = self.create_subscription(\n            JointTrajectory,\n            'joint_trajectory',\n            self.trajectory_callback,\n            10\n        )\n\n        # Publisher for joint commands (in a real system, this would go to hardware interface)\n        self.command_pub = self.create_publisher(JointState, 'joint_commands', 10)\n\n        # Publisher for controller status\n        self.status_pub = self.create_publisher(JointTrajectoryPoint, 'controller_status', 10)\n\n        # Current joint states (initially from simulation)\n        self.current_joint_states = None\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Controller state\n        self.active_trajectory = None\n        self.trajectory_start_time = None\n        self.current_point_idx = 0\n\n        # Timer for executing trajectories\n        self.timer = self.create_timer(0.01, self.execute_trajectory)  # 100Hz\n\n        self.get_logger().info('Trajectory Controller initialized')\n\n    def joint_state_callback(self, msg):\n        self.current_joint_states = msg\n\n    def trajectory_callback(self, msg):\n        self.get_logger().info(f'Received trajectory with {len(msg.points)} points')\n        self.active_trajectory = msg\n        self.trajectory_start_time = self.get_clock().now()\n        self.current_point_idx = 0\n\n    def execute_trajectory(self):\n        if self.active_trajectory is None or self.current_joint_states is None:\n            return\n\n        # Calculate elapsed time since trajectory started\n        current_time = self.get_clock().now()\n        elapsed = (current_time.nanoseconds - self.trajectory_start_time.nanoseconds) / 1e9\n\n        # Check if trajectory is complete\n        if self.current_point_idx >= len(self.active_trajectory.points):\n            self.active_trajectory = None\n            return\n\n        # Get the target point based on time\n        target_point = self.active_trajectory.points[self.current_point_idx]\n        target_time = target_point.time_from_start.sec + target_point.time_from_start.nanosec / 1e9\n\n        if elapsed >= target_time:\n            # Move to next point\n            self.current_point_idx += 1\n\n            if self.current_point_idx < len(self.active_trajectory.points):\n                # Publish the new target as a command\n                cmd_msg = JointState()\n                cmd_msg.header.stamp = self.get_clock().now().to_msg()\n                cmd_msg.name = self.active_trajectory.joint_names\n                cmd_msg.position = self.active_trajectory.points[self.current_point_idx-1].positions\n                cmd_msg.velocity = self.active_trajectory.points[self.current_point_idx-1].velocities\n                cmd_msg.effort = self.active_trajectory.points[self.current_point_idx-1].effort\n\n                self.command_pub.publish(cmd_msg)\n\n                # Publish status\n                status_msg = self.active_trajectory.points[self.current_point_idx-1]\n                self.status_pub.publish(status_msg)\n            else:\n                # Trajectory complete\n                self.active_trajectory = None\n                self.get_logger().info('Trajectory execution complete')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TrajectoryController()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-implement-command-interface",children:"Step 4: Implement Command Interface"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/command_interface.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\n\nclass CommandInterface(Node):\n    def __init__(self):\n        super().__init__('command_interface')\n\n        # Publisher for trajectory commands\n        self.trajectory_pub = self.create_publisher(JointTrajectory, 'joint_trajectory', 10)\n\n        # Timer to send a demonstration trajectory\n        self.timer = self.create_timer(5.0, self.send_demo_trajectory)\n\n        self.demo_count = 0\n\n        self.get_logger().info('Command Interface initialized')\n\n    def send_demo_trajectory(self):\n        msg = JointTrajectory()\n        msg.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\n            'head_pan_joint', 'head_tilt_joint'\n        ]\n\n        # Create trajectory points\n        point1 = JointTrajectoryPoint()\n        point1.positions = [0.0] * len(msg.joint_names)  # Home position\n        point1.velocities = [0.0] * len(msg.joint_names)\n        point1.accelerations = [0.0] * len(msg.joint_names)\n        point1.time_from_start = Duration(sec=1, nanosec=0)\n\n        point2 = JointTrajectoryPoint()\n        # Simple movement: lift left arm\n        positions = [0.0] * len(msg.joint_names)\n        positions[6] = 0.5  # left_shoulder_joint\n        positions[7] = 0.3  # left_elbow_joint\n        point2.positions = positions\n        point2.velocities = [0.0] * len(msg.joint_names)\n        point2.accelerations = [0.0] * len(msg.joint_names)\n        point2.time_from_start = Duration(sec=2, nanosec=0)\n\n        point3 = JointTrajectoryPoint()\n        # Return to home position\n        point3.positions = [0.0] * len(msg.joint_names)\n        point3.velocities = [0.0] * len(msg.joint_names)\n        point3.accelerations = [0.0] * len(msg.joint_names)\n        point3.time_from_start = Duration(sec=3, nanosec=0)\n\n        msg.points = [point1, point2, point3]\n\n        self.trajectory_pub.publish(msg)\n        self.get_logger().info(f'Sent demo trajectory #{self.demo_count + 1}')\n        self.demo_count += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CommandInterface()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-5-create-setup-file",children:"Step 5: Create Setup File"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"humanoid_control_stack/setup.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\nimport os\nfrom glob import glob\n\npackage_name = 'humanoid_control_stack'\n\nsetup(\n    name=package_name,\n    version='0.0.1',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='Student',\n    maintainer_email='student@university.edu',\n    description='ROS 2 Control Stack for Humanoid Robot',\n    license='MIT',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'joint_state_publisher = humanoid_control_stack.joint_state_publisher:main',\n            'trajectory_controller = humanoid_control_stack.trajectory_controller:main',\n            'command_interface = humanoid_control_stack.command_interface:main',\n        ],\n    },\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-6-create-launch-file",children:"Step 6: Create Launch File"}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"humanoid_control_stack/launch/control_stack_launch.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='humanoid_control_stack',\n            executable='joint_state_publisher',\n            name='joint_state_publisher',\n            output='screen'\n        ),\n        Node(\n            package='humanoid_control_stack',\n            executable='trajectory_controller',\n            name='trajectory_controller',\n            output='screen'\n        ),\n        Node(\n            package='humanoid_control_stack',\n            executable='command_interface',\n            name='command_interface',\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-your-implementation",children:"Testing Your Implementation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Build the package"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select humanoid_control_stack\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run the system"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 launch humanoid_control_stack control_stack_launch.py\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Monitor the system"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check published joint states\nros2 topic echo /joint_states\n\n# Check controller status\nros2 topic echo /controller_status\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"project-deliverables",children:"Project Deliverables"}),"\n",(0,i.jsx)(n.p,{children:"Submit the following for evaluation:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Complete source code for all nodes"}),"\n",(0,i.jsx)(n.li,{children:"Launch file to start the entire system"}),"\n",(0,i.jsx)(n.li,{children:"A README.md file explaining your implementation"}),"\n",(0,i.jsx)(n.li,{children:"Screenshots or logs showing successful execution of the demonstration trajectory"}),"\n",(0,i.jsxs)(n.li,{children:["A brief report (1-2 pages) describing:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design decisions made during implementation"}),"\n",(0,i.jsx)(n.li,{children:"Challenges encountered and how you addressed them"}),"\n",(0,i.jsx)(n.li,{children:"How your system follows ROS 2 best practices"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,i.jsx)(n.p,{children:"Your project will be evaluated on:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Functionality"})," (40%): Does the system correctly implement the required nodes and communication patterns?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code Quality"})," (25%): Is the code well-structured, documented, and following Python/ROS 2 best practices?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design"})," (20%): Does the architecture effectively separate concerns and follow ROS 2 principles?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing"})," (15%): Does the implementation include proper error handling and validation?"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"extension-challenges",children:"Extension Challenges"}),"\n",(0,i.jsx)(n.p,{children:"For additional learning, consider implementing:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PID Controllers"}),": Add PID controllers for more precise joint control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Features"}),": Implement joint limits and collision avoidance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advanced Trajectories"}),": Support for smooth, interpolated trajectories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time Performance"}),": Optimize for real-time constraints"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This mini-project demonstrates the practical application of ROS 2 concepts in creating a functional control system for a humanoid robot. You've implemented a distributed system with multiple nodes that communicate effectively to achieve a common goal."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"After completing this mini-project, you'll have a solid foundation in ROS 2 concepts and implementation. In Module 2, you'll integrate this control stack with simulation environments to test your robot in virtual worlds."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);