"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[1594],{8283:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-1","title":"Chapter 1: ROS 2 Architecture","description":"This chapter introduces the fundamental architecture of ROS 2 (Robot Operating System 2), the communication backbone that enables distributed robotic systems to work together seamlessly.","source":"@site/docs/module-1-robotic-nervous-system/chapter-1.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-1","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-1","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/chapter-1.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Chapter 1: ROS 2 Architecture","sidebar_position":1},"sidebar":"textbookSidebar","previous":{"title":"Learning Objectives","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/learning-objectives"},"next":{"title":"Chapter 2: Python Integration with rclpy","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-2"}}');var i=s(4848),r=s(8453);const o={sidebar_label:"Chapter 1: ROS 2 Architecture",sidebar_position:1},c="Chapter 1: ROS 2 Architecture",a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to ROS 2",id:"introduction-to-ros-2",level:2},{value:"Core Architecture Components",id:"core-architecture-components",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Topics and Messages",id:"topics-and-messages",level:3},{value:"Services",id:"services",level:3},{value:"Actions",id:"actions",level:3},{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Publisher-Subscriber Pattern",id:"publisher-subscriber-pattern",level:3},{value:"Service Client-Server Pattern",id:"service-client-server-pattern",level:3},{value:"Action Client-Server Pattern",id:"action-client-server-pattern",level:3},{value:"Practical Example: Simple Robot System",id:"practical-example-simple-robot-system",level:2},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"chapter-1-ros-2-architecture",children:"Chapter 1: ROS 2 Architecture"})}),"\n",(0,i.jsx)(t.p,{children:"This chapter introduces the fundamental architecture of ROS 2 (Robot Operating System 2), the communication backbone that enables distributed robotic systems to work together seamlessly."}),"\n",(0,i.jsx)(t.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(t.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Explain the core concepts of ROS 2 architecture"}),"\n",(0,i.jsx)(t.li,{children:"Identify and describe the main components (nodes, topics, services, actions)"}),"\n",(0,i.jsx)(t.li,{children:"Understand the communication patterns in ROS 2"}),"\n",(0,i.jsx)(t.li,{children:"Design basic communication structures for robotic systems"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"introduction-to-ros-2",children:"Introduction to ROS 2"}),"\n",(0,i.jsx)(t.p,{children:"ROS 2 is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms. Unlike traditional monolithic approaches, ROS 2 uses a distributed architecture where different components (nodes) communicate with each other through a publish-subscribe model."}),"\n",(0,i.jsx)(t.p,{children:"ROS 2 represents a significant evolution from ROS 1, addressing key concerns like security, real-time performance, and support for commercial applications. It's designed to be suitable for real applications, from research and prototyping to production systems."}),"\n",(0,i.jsx)(t.h2,{id:"core-architecture-components",children:"Core Architecture Components"}),"\n",(0,i.jsx)(t.h3,{id:"nodes",children:"Nodes"}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.strong,{children:"node"})," is an executable that uses ROS 2 to communicate with other nodes. Nodes are the fundamental building blocks of a ROS 2 system. Each node typically performs a specific task and communicates with other nodes to achieve more complex robot behaviors."]}),"\n",(0,i.jsx)(t.admonition,{title:"Key Concept",type:"info",children:(0,i.jsx)(t.p,{children:"Think of nodes as individual processes or services that each handle a specific function, like perception, control, or planning."})}),"\n",(0,i.jsx)(t.h3,{id:"topics-and-messages",children:"Topics and Messages"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Topics"})," are named buses over which nodes exchange messages. The communication is based on a publish-subscribe pattern where publishers send messages to a topic and subscribers receive messages from a topic. This enables loose coupling between nodes."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Messages"})," are the data structures that are passed between nodes. They are defined using the ",(0,i.jsx)(t.code,{children:".msg"})," file format and contain primitive data types like integers, floats, booleans, and strings, as well as arrays of these types."]}),"\n",(0,i.jsx)(t.h3,{id:"services",children:"Services"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Services"})," provide a request-response communication pattern. Unlike topics which are asynchronous, services are synchronous - the client sends a request and waits for a response from the server. Services are useful for operations that need a direct response, like requesting specific robot actions or configuration changes."]}),"\n",(0,i.jsx)(t.h3,{id:"actions",children:"Actions"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Actions"})," are a more advanced communication pattern that combines features of both topics and services. They're designed for long-running tasks that require feedback during execution and the ability to cancel the operation. Actions are perfect for navigation goals, manipulation tasks, or any operation that takes time to complete."]}),"\n",(0,i.jsx)(t.h2,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"publisher-subscriber-pattern",children:"Publisher-Subscriber Pattern"}),"\n",(0,i.jsx)(t.p,{children:"The publisher-subscriber pattern enables loose coupling between nodes. Publishers send data to topics without knowing who (if anyone) is subscribed. Subscribers receive data from topics without knowing who published the data."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Example publisher\r\npublisher = node.create_publisher(StringMsg, 'topic_name', 10)\r\nmsg = StringMsg()\r\nmsg.data = 'Hello World'\r\npublisher.publish(msg)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"service-client-server-pattern",children:"Service Client-Server Pattern"}),"\n",(0,i.jsx)(t.p,{children:"The service pattern provides direct request-response communication between nodes."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Example service server\r\nservice = node.create_service(AddTwoInts, 'add_two_ints', callback_function)\r\n\r\n# Example service client\r\nclient = node.create_client(AddTwoInts, 'add_two_ints')\n"})}),"\n",(0,i.jsx)(t.h3,{id:"action-client-server-pattern",children:"Action Client-Server Pattern"}),"\n",(0,i.jsx)(t.p,{children:"Actions provide feedback during long-running operations and the ability to cancel."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Example action server\r\naction_server = ActionServer(node, Fibonacci, 'fibonacci', execute_callback)\r\n\r\n# Example action client\r\naction_client = ActionClient(node, Fibonacci, 'fibonacci')\n"})}),"\n",(0,i.jsx)(t.h2,{id:"practical-example-simple-robot-system",children:"Practical Example: Simple Robot System"}),"\n",(0,i.jsx)(t.p,{children:"Let's consider a simple robot system with three nodes:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Sensor Node"}),": Publishes sensor data (e.g., laser scans) to a topic"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Controller Node"}),": Subscribes to sensor data, processes it, and publishes motor commands"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Motor Node"}),": Subscribes to motor commands and controls the physical motors"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This architecture allows each component to be developed, tested, and maintained independently while working together as a system."}),"\n",(0,i.jsx)(t.h2,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,i.jsx)(t.p,{children:"ROS 2 provides Quality of Service (QoS) settings that allow you to fine-tune communication behavior. QoS settings control aspects like reliability, durability, and history of messages, which is crucial for real-time and safety-critical applications."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Reliability"}),": Whether messages are guaranteed to be delivered"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Durability"}),": Whether late-joining subscribers get old messages"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"History"}),": How many messages to store for late-joining subscribers"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"ROS 2's distributed architecture enables the creation of complex robotic systems by breaking them down into smaller, manageable components that communicate through well-defined interfaces. Understanding these core concepts is essential for designing effective robotic systems."}),"\n",(0,i.jsx)(t.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Conceptual Exercise"}),": Draw a diagram showing the communication between nodes in a mobile robot with laser scanner, camera, and motor controllers."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Research Exercise"}),": Investigate how QoS settings affect communication in a ROS 2 system and when you might use different configurations."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Design Exercise"}),": Design a ROS 2 architecture for a humanoid robot with multiple sensors (IMU, cameras, joint encoders) and actuators (arm joints, leg joints, head pan-tilt)."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(t.p,{children:["In the next chapter, we'll explore how to implement these concepts using Python and the ",(0,i.jsx)(t.code,{children:"rclpy"})," library, diving into practical ROS 2 programming."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>c});var n=s(6540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);