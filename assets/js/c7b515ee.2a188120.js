"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[6714],{5163:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-5","title":"Chapter 5: Sensor-Actuator-Control Pipelines","description":"This chapter explores the integration of sensors, actuators, and control systems in ROS 2, forming the complete feedback loops necessary for autonomous robot operation. You\'ll learn how to create sensor-actuator-control pipelines that enable robots to perceive their environment, make decisions, and execute actions.","source":"@site/docs/module-1-robotic-nervous-system/chapter-5.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-5","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/chapter-5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"Chapter 5: Sensor-Actuator-Control Pipelines","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"Chapter 4: URDF Modeling for Humanoids","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-4"},"next":{"title":"Exercises","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/exercises"}}');var o=n(4848),s=n(8453);const i={sidebar_label:"Chapter 5: Sensor-Actuator-Control Pipelines",sidebar_position:5},l="Chapter 5: Sensor-Actuator-Control Pipelines",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Sensor-Actuator-Controller Architecture",id:"introduction-to-sensor-actuator-controller-architecture",level:2},{value:"Sensor Types and Integration",id:"sensor-types-and-integration",level:2},{value:"Joint Position Sensors (Encoders)",id:"joint-position-sensors-encoders",level:3},{value:"IMU (Inertial Measurement Unit) Sensors",id:"imu-inertial-measurement-unit-sensors",level:3},{value:"Camera and Vision Sensors",id:"camera-and-vision-sensors",level:3},{value:"Control System Implementation",id:"control-system-implementation",level:2},{value:"PID Controller Example",id:"pid-controller-example",level:3},{value:"Joint Controller Node",id:"joint-controller-node",level:3},{value:"Safety and Error Handling",id:"safety-and-error-handling",level:2},{value:"Safety Monitor Node",id:"safety-monitor-node",level:3},{value:"Complete Pipeline Integration",id:"complete-pipeline-integration",level:2},{value:"Launch File for Complete Pipeline",id:"launch-file-for-complete-pipeline",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Real-Time Considerations",id:"real-time-considerations",level:3},{value:"Safety First",id:"safety-first",level:3},{value:"Modularity",id:"modularity",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"chapter-5-sensor-actuator-control-pipelines",children:"Chapter 5: Sensor-Actuator-Control Pipelines"})}),"\n",(0,o.jsx)(r.p,{children:"This chapter explores the integration of sensors, actuators, and control systems in ROS 2, forming the complete feedback loops necessary for autonomous robot operation. You'll learn how to create sensor-actuator-control pipelines that enable robots to perceive their environment, make decisions, and execute actions."}),"\n",(0,o.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(r.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Design sensor-actuator feedback loops for robotic systems"}),"\n",(0,o.jsx)(r.li,{children:"Implement control pipelines that process sensor data and command actuators"}),"\n",(0,o.jsx)(r.li,{children:"Integrate various sensor types (IMU, encoders, cameras, LiDAR) into control systems"}),"\n",(0,o.jsx)(r.li,{children:"Implement safety mechanisms and error handling in control pipelines"}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"introduction-to-sensor-actuator-controller-architecture",children:"Introduction to Sensor-Actuator-Controller Architecture"}),"\n",(0,o.jsx)(r.p,{children:"The sensor-actuator-control pipeline forms the foundation of autonomous robotic systems. It creates a feedback loop where sensors provide information about the robot's state and environment, controllers process this information to make decisions, and actuators execute the resulting commands."}),"\n",(0,o.jsx)(r.p,{children:"The typical pipeline follows this pattern:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"Sensors \u2192 Sensor Processing \u2192 State Estimation \u2192 Controller \u2192 Actuator Commands \u2192 Actuators \u2192 Robot \u2192 Environment \u2192 Sensors (feedback)\n"})}),"\n",(0,o.jsx)(r.h2,{id:"sensor-types-and-integration",children:"Sensor Types and Integration"}),"\n",(0,o.jsx)(r.h3,{id:"joint-position-sensors-encoders",children:"Joint Position Sensors (Encoders)"}),"\n",(0,o.jsx)(r.p,{children:"Joint position sensors provide feedback about the current position of robot joints:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nimport math\r\n\r\nclass JointStateProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_state_processor')\r\n\r\n        # Subscribe to joint states\r\n        self.subscription = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for processed joint data\r\n        self.joint_pub = self.create_publisher(JointState, 'processed_joint_states', 10)\r\n\r\n        # Store previous joint states for velocity calculation\r\n        self.prev_positions = {}\r\n        self.prev_times = {}\r\n\r\n        self.get_logger().info('Joint State Processor initialized')\r\n\r\n    def joint_state_callback(self, msg):\r\n        current_time = self.get_clock().now().nanoseconds / 1e9\r\n\r\n        processed_msg = JointState()\r\n        processed_msg.header = msg.header\r\n        processed_msg.name = msg.name\r\n        processed_msg.position = msg.position\r\n        processed_msg.velocity = []\r\n        processed_msg.effort = msg.effort\r\n\r\n        # Calculate velocities from position changes\r\n        for i, (name, pos) in enumerate(zip(msg.name, msg.position)):\r\n            if name in self.prev_positions:\r\n                dt = current_time - self.prev_times[name]\r\n                if dt > 0:\r\n                    vel = (pos - self.prev_positions[name]) / dt\r\n                    processed_msg.velocity.append(vel)\r\n                else:\r\n                    processed_msg.velocity.append(0.0)\r\n            else:\r\n                processed_msg.velocity.append(0.0)\r\n\r\n            # Update stored values\r\n            self.prev_positions[name] = pos\r\n            self.prev_times[name] = current_time\r\n\r\n        # Publish processed joint states\r\n        self.joint_pub.publish(processed_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    processor = JointStateProcessor()\r\n    rclpy.spin(processor)\r\n    processor.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h3,{id:"imu-inertial-measurement-unit-sensors",children:"IMU (Inertial Measurement Unit) Sensors"}),"\n",(0,o.jsx)(r.p,{children:"IMU sensors provide orientation, angular velocity, and linear acceleration:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Imu\r\nfrom geometry_msgs.msg import Vector3\r\nimport numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\n\r\nclass ImuProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('imu_processor')\r\n\r\n        # Subscribe to IMU data\r\n        self.subscription = self.create_subscription(\r\n            Imu,\r\n            'imu/data',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for processed orientation\r\n        self.orientation_pub = self.create_publisher(Vector3, 'robot_orientation', 10)\r\n\r\n        # Store previous data for filtering\r\n        self.prev_orientation = None\r\n        self.orientation_history = []\r\n\r\n        self.get_logger().info('IMU Processor initialized')\r\n\r\n    def imu_callback(self, msg):\r\n        # Extract quaternion from IMU message\r\n        quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]\r\n\r\n        # Convert to Euler angles (roll, pitch, yaw)\r\n        rotation = R.from_quat(quat)\r\n        euler = rotation.as_euler('xyz', degrees=True)\r\n\r\n        # Create Vector3 message with Euler angles\r\n        orientation_msg = Vector3()\r\n        orientation_msg.x = euler[0]  # roll\r\n        orientation_msg.y = euler[1]  # pitch\r\n        orientation_msg.z = euler[2]  # yaw\r\n\r\n        # Publish processed orientation\r\n        self.orientation_pub.publish(orientation_msg)\r\n\r\n        # Store for filtering if needed\r\n        self.orientation_history.append(euler)\r\n        if len(self.orientation_history) > 10:\r\n            self.orientation_history.pop(0)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    processor = ImuProcessor()\r\n    rclpy.spin(processor)\r\n    processor.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h3,{id:"camera-and-vision-sensors",children:"Camera and Vision Sensors"}),"\n",(0,o.jsx)(r.p,{children:"Camera sensors provide visual information for perception:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\nimport cv2\r\nimport numpy as np\r\n\r\nclass VisionProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('vision_processor')\r\n\r\n        # Create OpenCV bridge\r\n        self.bridge = CvBridge()\r\n\r\n        # Subscribe to camera feed\r\n        self.subscription = self.create_subscription(\r\n            Image,\r\n            'camera/image_raw',\r\n            self.image_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for processed image\r\n        self.processed_pub = self.create_publisher(Image, 'camera/image_processed', 10)\r\n\r\n        self.get_logger().info('Vision Processor initialized')\r\n\r\n    def image_callback(self, msg):\r\n        try:\r\n            # Convert ROS Image message to OpenCV image\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\r\n\r\n            # Process the image (example: edge detection)\r\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\r\n            edges = cv2.Canny(gray, 50, 150)\r\n\r\n            # Convert back to ROS Image message\r\n            processed_msg = self.bridge.cv2_to_imgmsg(edges, encoding='mono8')\r\n            processed_msg.header = msg.header\r\n\r\n            # Publish processed image\r\n            self.processed_pub.publish(processed_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing image: {e}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    processor = VisionProcessor()\r\n    rclpy.spin(processor)\r\n    processor.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h2,{id:"control-system-implementation",children:"Control System Implementation"}),"\n",(0,o.jsx)(r.h3,{id:"pid-controller-example",children:"PID Controller Example"}),"\n",(0,o.jsx)(r.p,{children:"A PID (Proportional-Integral-Derivative) controller is fundamental for precise control:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"class PIDController:\r\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, min_output=-1.0, max_output=1.0):\r\n        self.kp = kp\r\n        self.ki = ki\r\n        self.kd = kd\r\n        self.min_output = min_output\r\n        self.max_output = max_output\r\n\r\n        self.prev_error = 0.0\r\n        self.integral = 0.0\r\n        self.prev_time = None\r\n\r\n    def compute(self, setpoint, current_value, dt=None):\r\n        current_time = time.time()\r\n\r\n        if dt is None and self.prev_time is not None:\r\n            dt = current_time - self.prev_time\r\n        elif dt is None:\r\n            dt = 0.01  # Default time step\r\n\r\n        # Calculate error\r\n        error = setpoint - current_value\r\n\r\n        # Proportional term\r\n        p_term = self.kp * error\r\n\r\n        # Integral term\r\n        self.integral += error * dt\r\n        i_term = self.ki * self.integral\r\n\r\n        # Derivative term\r\n        if dt > 0:\r\n            derivative = (error - self.prev_error) / dt\r\n        else:\r\n            derivative = 0.0\r\n        d_term = self.kd * derivative\r\n\r\n        # Calculate output\r\n        output = p_term + i_term + d_term\r\n\r\n        # Clamp output to limits\r\n        output = max(self.min_output, min(self.max_output, output))\r\n\r\n        # Store values for next iteration\r\n        self.prev_error = error\r\n        self.prev_time = current_time\r\n\r\n        return output\n"})}),"\n",(0,o.jsx)(r.h3,{id:"joint-controller-node",children:"Joint Controller Node"}),"\n",(0,o.jsx)(r.p,{children:"Here's a complete joint controller that integrates sensor feedback with actuator commands:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import Float64MultiArray\r\nfrom builtin_interfaces.msg import Duration\r\nimport numpy as np\r\n\r\nclass JointController(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_controller')\r\n\r\n        # Controller parameters\r\n        self.joint_names = [\r\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\r\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\r\n        ]\r\n\r\n        # PID controllers for each joint\r\n        self.pid_controllers = {}\r\n        for joint_name in self.joint_names:\r\n            self.pid_controllers[joint_name] = PIDController(\r\n                kp=2.0, ki=0.1, kd=0.05,\r\n                min_output=-10.0, max_output=10.0\r\n            )\r\n\r\n        # Current joint states\r\n        self.current_positions = {name: 0.0 for name in self.joint_names}\r\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\r\n\r\n        # Target positions (initially current positions)\r\n        self.target_positions = self.current_positions.copy()\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        # Publishers\r\n        self.command_pub = self.create_publisher(\r\n            Float64MultiArray,\r\n            '/joint_group_position_controller/commands',\r\n            10\r\n        )\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100Hz\r\n\r\n        self.get_logger().info('Joint Controller initialized')\r\n\r\n    def joint_state_callback(self, msg):\r\n        # Update current joint states\r\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\r\n            if name in self.current_positions:\r\n                self.current_positions[name] = pos\r\n                self.current_velocities[name] = vel\r\n\r\n    def control_loop(self):\r\n        # Calculate control commands for each joint\r\n        commands = []\r\n\r\n        for joint_name in self.joint_names:\r\n            current_pos = self.current_positions[joint_name]\r\n            target_pos = self.target_positions[joint_name]\r\n\r\n            # Compute control effort using PID\r\n            effort = self.pid_controllers[joint_name].compute(\r\n                target_pos, current_pos\r\n            )\r\n\r\n            commands.append(effort)\r\n\r\n        # Publish commands\r\n        command_msg = Float64MultiArray()\r\n        command_msg.data = commands\r\n        self.command_pub.publish(command_msg)\r\n\r\n    def set_target_positions(self, positions_dict):\r\n        \"\"\"Set target positions for joints\"\"\"\r\n        for joint_name, target_pos in positions_dict.items():\r\n            if joint_name in self.target_positions:\r\n                self.target_positions[joint_name] = target_pos\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = JointController()\r\n\r\n    # Example: Set a target position after startup\r\n    def set_initial_target():\r\n        controller.set_target_positions({\r\n            'left_hip_joint': 0.1,\r\n            'right_hip_joint': 0.1\r\n        })\r\n\r\n    # Schedule initial target after a short delay\r\n    timer = controller.create_timer(1.0, set_initial_target)\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h2,{id:"safety-and-error-handling",children:"Safety and Error Handling"}),"\n",(0,o.jsx)(r.h3,{id:"safety-monitor-node",children:"Safety Monitor Node"}),"\n",(0,o.jsx)(r.p,{children:"A safety monitor watches the system and implements safety mechanisms:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom std_msgs.msg import Bool\r\nimport numpy as np\r\n\r\nclass SafetyMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('safety_monitor')\r\n\r\n        # Safety parameters\r\n        self.joint_limits = {\r\n            'left_hip_joint': (-1.5, 1.5),\r\n            'left_knee_joint': (0.0, 2.5),\r\n            'left_ankle_joint': (-0.5, 0.5),\r\n            'right_hip_joint': (-1.5, 1.5),\r\n            'right_knee_joint': (0.0, 2.5),\r\n            'right_ankle_joint': (-0.5, 0.5)\r\n        }\r\n\r\n        self.max_velocity = 5.0  # rad/s\r\n        self.max_tilt = 0.5  # rad (about 28 degrees)\r\n\r\n        # Safety state\r\n        self.emergency_stop = False\r\n        self.safety_violation = False\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        self.imu_sub = self.create_subscription(\r\n            Imu,\r\n            'imu/data',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for safety state\r\n        self.safety_pub = self.create_publisher(Bool, 'safety_status', 10)\r\n\r\n        # Timer for safety checks\r\n        self.safety_timer = self.create_timer(0.1, self.safety_check)  # 10Hz\r\n\r\n        self.get_logger().info('Safety Monitor initialized')\r\n\r\n    def joint_state_callback(self, msg):\r\n        if self.emergency_stop:\r\n            return\r\n\r\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\r\n            if name in self.joint_limits:\r\n                # Check position limits\r\n                min_limit, max_limit = self.joint_limits[name]\r\n                if pos < min_limit or pos > max_limit:\r\n                    self.safety_violation = True\r\n                    self.get_logger().error(f'Joint {name} exceeded position limits: {pos}')\r\n                    self.trigger_emergency_stop()\r\n                    return\r\n\r\n                # Check velocity limits\r\n                if abs(vel) > self.max_velocity:\r\n                    self.safety_violation = True\r\n                    self.get_logger().error(f'Joint {name} exceeded velocity limits: {vel}')\r\n                    self.trigger_emergency_stop()\r\n                    return\r\n\r\n    def imu_callback(self, msg):\r\n        if self.emergency_stop:\r\n            return\r\n\r\n        # Extract orientation from IMU\r\n        quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]\r\n\r\n        # Convert to Euler angles\r\n        from scipy.spatial.transform import Rotation as R\r\n        rotation = R.from_quat(quat)\r\n        euler = rotation.as_euler('xyz')\r\n\r\n        # Check tilt angles\r\n        roll, pitch, yaw = euler\r\n        if abs(roll) > self.max_tilt or abs(pitch) > self.max_tilt:\r\n            self.safety_violation = True\r\n            self.get_logger().error(f'Robot exceeded tilt limits: roll={roll:.2f}, pitch={pitch:.2f}')\r\n            self.trigger_emergency_stop()\r\n            return\r\n\r\n    def safety_check(self):\r\n        # Publish current safety status\r\n        safety_msg = Bool()\r\n        safety_msg.data = not self.emergency_stop\r\n        self.safety_pub.publish(safety_msg)\r\n\r\n    def trigger_emergency_stop(self):\r\n        self.emergency_stop = True\r\n        self.get_logger().error('EMERGENCY STOP TRIGGERED - Safety violation detected!')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    monitor = SafetyMonitor()\r\n    rclpy.spin(monitor)\r\n    monitor.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h2,{id:"complete-pipeline-integration",children:"Complete Pipeline Integration"}),"\n",(0,o.jsx)(r.p,{children:"Here's an example of how to integrate all components into a complete sensor-actuator-control pipeline:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom std_msgs.msg import Float64MultiArray, Bool\r\nimport numpy as np\r\n\r\nclass CompleteControlPipeline(Node):\r\n    def __init__(self):\r\n        super().__init__('complete_control_pipeline')\r\n\r\n        # Control state\r\n        self.joint_names = [\r\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\r\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\r\n        ]\r\n\r\n        self.current_positions = {name: 0.0 for name in self.joint_names}\r\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\r\n        self.target_positions = {name: 0.0 for name in self.joint_names}\r\n\r\n        # PID controllers\r\n        self.pid_controllers = {}\r\n        for name in self.joint_names:\r\n            self.pid_controllers[name] = PIDController(\r\n                kp=2.0, ki=0.1, kd=0.05,\r\n                min_output=-10.0, max_output=10.0\r\n            )\r\n\r\n        # Safety state\r\n        self.safety_enabled = True\r\n        self.emergency_stop = False\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        self.imu_sub = self.create_subscription(\r\n            Imu,\r\n            'imu/data',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n\r\n        self.safety_sub = self.create_subscription(\r\n            Bool,\r\n            'safety_status',\r\n            self.safety_callback,\r\n            10\r\n        )\r\n\r\n        # Publishers\r\n        self.command_pub = self.create_publisher(\r\n            Float64MultiArray,\r\n            '/joint_group_position_controller/commands',\r\n            10\r\n        )\r\n\r\n        # Control timer\r\n        self.control_timer = self.create_timer(0.01, self.control_loop)\r\n\r\n        self.get_logger().info('Complete Control Pipeline initialized')\r\n\r\n    def joint_state_callback(self, msg):\r\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\r\n            if name in self.current_positions:\r\n                self.current_positions[name] = pos\r\n                self.current_velocities[name] = vel\r\n\r\n    def imu_callback(self, msg):\r\n        # Process IMU data if needed for control\r\n        pass\r\n\r\n    def safety_callback(self, msg):\r\n        self.safety_enabled = msg.data\r\n\r\n    def control_loop(self):\r\n        if not self.safety_enabled or self.emergency_stop:\r\n            # Send zero commands during safety stop\r\n            zero_commands = [0.0] * len(self.joint_names)\r\n            command_msg = Float64MultiArray()\r\n            command_msg.data = zero_commands\r\n            self.command_pub.publish(command_msg)\r\n            return\r\n\r\n        # Calculate control commands\r\n        commands = []\r\n        for name in self.joint_names:\r\n            current_pos = self.current_positions[name]\r\n            target_pos = self.target_positions[name]\r\n\r\n            effort = self.pid_controllers[name].compute(target_pos, current_pos)\r\n            commands.append(effort)\r\n\r\n        # Publish commands\r\n        command_msg = Float64MultiArray()\r\n        command_msg.data = commands\r\n        self.command_pub.publish(command_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    pipeline = CompleteControlPipeline()\r\n    rclpy.spin(pipeline)\r\n    pipeline.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(r.h2,{id:"launch-file-for-complete-pipeline",children:"Launch File for Complete Pipeline"}),"\n",(0,o.jsxs)(r.p,{children:["Create ",(0,o.jsx)(r.code,{children:"launch/sensor_actuator_pipeline_launch.py"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        # Joint state publisher (simulated robot)\r\n        Node(\r\n            package='joint_state_publisher',\r\n            executable='joint_state_publisher',\r\n            name='joint_state_publisher',\r\n            parameters=[{'use_sim_time': True}]\r\n        ),\r\n\r\n        # Robot state publisher\r\n        Node(\r\n            package='robot_state_publisher',\r\n            executable='robot_state_publisher',\r\n            name='robot_state_publisher',\r\n            parameters=[{'use_sim_time': True}]\r\n        ),\r\n\r\n        # Sensor processors\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='joint_state_processor',\r\n            name='joint_state_processor',\r\n            output='screen'\r\n        ),\r\n\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='imu_processor',\r\n            name='imu_processor',\r\n            output='screen'\r\n        ),\r\n\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='vision_processor',\r\n            name='vision_processor',\r\n            output='screen'\r\n        ),\r\n\r\n        # Controllers\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='joint_controller',\r\n            name='joint_controller',\r\n            output='screen'\r\n        ),\r\n\r\n        # Safety monitor\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='safety_monitor',\r\n            name='safety_monitor',\r\n            output='screen'\r\n        ),\r\n\r\n        # Complete pipeline\r\n        Node(\r\n            package='my_robot_control',\r\n            executable='complete_control_pipeline',\r\n            name='complete_control_pipeline',\r\n            output='screen'\r\n        )\r\n    ])\n"})}),"\n",(0,o.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(r.h3,{id:"real-time-considerations",children:"Real-Time Considerations"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Use appropriate control frequencies (typically 100Hz for joint control)"}),"\n",(0,o.jsx)(r.li,{children:"Minimize computational complexity in control loops"}),"\n",(0,o.jsx)(r.li,{children:"Use efficient data structures and algorithms"}),"\n",(0,o.jsx)(r.li,{children:"Consider thread safety for concurrent access"}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"safety-first",children:"Safety First"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Always implement emergency stop functionality"}),"\n",(0,o.jsx)(r.li,{children:"Set appropriate limits for positions, velocities, and efforts"}),"\n",(0,o.jsx)(r.li,{children:"Monitor for safety violations continuously"}),"\n",(0,o.jsx)(r.li,{children:"Design fail-safe behaviors"}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"modularity",children:"Modularity"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Separate sensor processing, control, and actuation logic"}),"\n",(0,o.jsx)(r.li,{children:"Use ROS 2's composability features when appropriate"}),"\n",(0,o.jsx)(r.li,{children:"Design nodes to be reusable across different robots"}),"\n",(0,o.jsx)(r.li,{children:"Follow ROS 2 design patterns and conventions"}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(r.p,{children:"Sensor-actuator-control pipelines form the backbone of autonomous robotic systems. By properly integrating sensors, controllers, and actuators with appropriate safety mechanisms, you can create robust systems that operate reliably in real-world conditions."}),"\n",(0,o.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Pipeline Exercise"}),": Create a complete sensor-actuator-control pipeline for a simple mobile robot with wheel encoders and motor controllers."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Safety Exercise"}),": Implement additional safety checks for a humanoid robot, including collision detection and joint torque limits."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Integration Exercise"}),": Design a launch file that starts all components of your sensor-actuator-control pipeline and test it with a simulated robot."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(r.p,{children:"With the foundational ROS 2 concepts, launch files, URDF modeling, and sensor-actuator pipelines covered, you're ready to work on the Module 1 mini-project: building a complete ROS 2 control stack. This will integrate all the concepts learned in this module into a functional system."})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var t=n(6540);const o={},s=t.createContext(o);function i(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);