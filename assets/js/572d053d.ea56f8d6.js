"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[8985],{1376:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vla/chapter-8","title":"Chapter 8: LLM-Based Cognitive Planning to ROS Actions","description":"Overview","source":"@site/docs/module-4-vla/chapter-8.md","sourceDirName":"module-4-vla","slug":"/module-4-vla/chapter-8","permalink":"/ai-robotics-textbook/docs/module-4-vla/chapter-8","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-4-vla/chapter-8.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"Chapter 8: LLM-Based Cognitive Planning to ROS Actions","sidebar_position":2},"sidebar":"textbookSidebar","previous":{"title":"Chapter 7: Voice Processing with Whisper","permalink":"/ai-robotics-textbook/docs/module-4-vla/chapter-7"},"next":{"title":"Capstone Project: Autonomous Humanoid","permalink":"/ai-robotics-textbook/docs/module-4-vla/capstone-project"}}');var i=r(4848),a=r(8453);const s={sidebar_label:"Chapter 8: LLM-Based Cognitive Planning to ROS Actions",sidebar_position:2},o="Chapter 8: LLM-Based Cognitive Planning to ROS Actions",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"8.1 Introduction to LLM-Based Cognitive Planning",id:"81-introduction-to-llm-based-cognitive-planning",level:2},{value:"Cognitive Planning in Robotics",id:"cognitive-planning-in-robotics",level:3},{value:"Role of LLMs in Cognitive Planning",id:"role-of-llms-in-cognitive-planning",level:3},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"8.2 LLM Integration with ROS 2",id:"82-llm-integration-with-ros-2",level:2},{value:"Supported LLM Platforms",id:"supported-llm-platforms",level:3},{value:"Basic LLM Integration Example",id:"basic-llm-integration-example",level:3},{value:"8.3 Cognitive Architecture Design",id:"83-cognitive-architecture-design",level:2},{value:"Planning Hierarchy",id:"planning-hierarchy",level:3},{value:"Context Management",id:"context-management",level:3},{value:"Plan Validation and Safety",id:"plan-validation-and-safety",level:3},{value:"8.4 Multi-Step Task Planning",id:"84-multi-step-task-planning",level:2},{value:"Sequential Task Execution",id:"sequential-task-execution",level:3},{value:"8.5 LLM Prompt Engineering for Robotics",id:"85-llm-prompt-engineering-for-robotics",level:2},{value:"Effective Prompting Strategies",id:"effective-prompting-strategies",level:3},{value:"8.6 Handling Uncertainty and Adaptation",id:"86-handling-uncertainty-and-adaptation",level:2},{value:"Plan Adaptation System",id:"plan-adaptation-system",level:3},{value:"8.7 Integration with ROS 2 Ecosystem",id:"87-integration-with-ros-2-ecosystem",level:2},{value:"Service Definitions",id:"service-definitions",level:3},{value:"Action Integration",id:"action-integration",level:3},{value:"8.8 Practical Exercise: Cognitive Planning System",id:"88-practical-exercise-cognitive-planning-system",level:2},{value:"Exercise Objective",id:"exercise-objective",level:3},{value:"Steps",id:"steps",level:3},{value:"Expected Results",id:"expected-results",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-8-llm-based-cognitive-planning-to-ros-actions",children:"Chapter 8: LLM-Based Cognitive Planning to ROS Actions"})}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"This chapter covers the implementation of Large Language Model (LLM)-based cognitive planning systems that translate high-level natural language commands into executable ROS actions for humanoid robots. Students will learn to design cognitive architectures that enable robots to understand complex commands, plan multi-step tasks, and execute coordinated behaviors."}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Integrate LLMs with ROS 2 for cognitive planning"}),"\n",(0,i.jsx)(e.li,{children:"Design cognitive architectures for task planning and execution"}),"\n",(0,i.jsx)(e.li,{children:"Convert natural language commands to structured ROS action sequences"}),"\n",(0,i.jsx)(e.li,{children:"Implement multi-step task planning and execution"}),"\n",(0,i.jsx)(e.li,{children:"Handle task failures and plan adaptations"}),"\n",(0,i.jsx)(e.li,{children:"Validate cognitive planning accuracy and safety"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"81-introduction-to-llm-based-cognitive-planning",children:"8.1 Introduction to LLM-Based Cognitive Planning"}),"\n",(0,i.jsx)(e.h3,{id:"cognitive-planning-in-robotics",children:"Cognitive Planning in Robotics"}),"\n",(0,i.jsx)(e.p,{children:"Cognitive planning for robots involves:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Understanding"}),": Interpreting high-level commands in natural language"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reasoning"}),": Determining appropriate sequences of actions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Planning"}),": Creating detailed execution plans with temporal and spatial constraints"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Execution"}),": Coordinating ROS nodes and services to execute the plan"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitoring"}),": Tracking plan execution and adapting to changes"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"role-of-llms-in-cognitive-planning",children:"Role of LLMs in Cognitive Planning"}),"\n",(0,i.jsx)(e.p,{children:"Large Language Models serve as:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Natural Language Interface"}),": Converting human commands to structured representations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"World Model"}),": Maintaining knowledge about the environment and objects"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reasoning Engine"}),": Determining appropriate action sequences"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adaptation System"}),": Handling unexpected situations and plan modifications"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Natural Language Command\r\n         \u2193\r\n    [LLM] - Cognitive Reasoning\r\n         \u2193\r\nStructured Action Plan\r\n         \u2193\r\n   [Planner] - Task Decomposition\r\n         \u2193\r\nROS Action Sequence\r\n         \u2193\r\n   [Executor] - ROS Node Coordination\r\n         \u2193\r\nPhysical Robot Actions\n"})}),"\n",(0,i.jsx)(e.h2,{id:"82-llm-integration-with-ros-2",children:"8.2 LLM Integration with ROS 2"}),"\n",(0,i.jsx)(e.h3,{id:"supported-llm-platforms",children:"Supported LLM Platforms"}),"\n",(0,i.jsx)(e.p,{children:"For robotics applications, several LLM platforms can be integrated:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"OpenAI GPT Models"}),": High accuracy, cloud-based, requires API access"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Anthropic Claude"}),": Strong reasoning capabilities, cloud-based"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Open-Source Models"}),": Mistral, Llama 2/3, locally deployable"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Specialized Robotics Models"}),": Models fine-tuned for robotics tasks"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-llm-integration-example",children:"Basic LLM Integration Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nimport openai\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Pose\r\nfrom sensor_msgs.msg import Image\r\nimport json\r\nimport time\r\n\r\nclass LLMCognitivePlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'llm_cognitive_planner\')\r\n\r\n        # Initialize LLM client (using OpenAI as example)\r\n        # In practice, you might use other LLM providers or local models\r\n        self.llm_client = None  # Initialize based on your chosen provider\r\n\r\n        # Subscribers for various inputs\r\n        self.voice_command_sub = self.create_subscription(\r\n            String,\r\n            \'voice_command\',\r\n            self.voice_command_callback,\r\n            10\r\n        )\r\n\r\n        self.text_command_sub = self.create_subscription(\r\n            String,\r\n            \'text_command\',\r\n            self.text_command_callback,\r\n            10\r\n        )\r\n\r\n        # Publishers for planning outputs\r\n        self.plan_pub = self.create_publisher(\r\n            String,\r\n            \'cognitive_plan\',\r\n            10\r\n        )\r\n\r\n        self.action_pub = self.create_publisher(\r\n            String,\r\n            \'planned_actions\',\r\n            10\r\n        )\r\n\r\n        # Service clients for robot capabilities\r\n        self.nav_client = self.create_client(\r\n            NavigateToPose,\r\n            \'navigate_to_pose\'\r\n        )\r\n\r\n        self.manipulation_client = self.create_client(\r\n            ManipulationCommand,\r\n            \'manipulation_command\'\r\n        )\r\n\r\n        self.get_logger().info(\'LLM Cognitive Planner initialized\')\r\n\r\n    def voice_command_callback(self, msg):\r\n        """Process voice command through LLM cognitive planner"""\r\n        self.process_command(msg.data, command_type=\'voice\')\r\n\r\n    def text_command_callback(self, msg):\r\n        """Process text command through LLM cognitive planner"""\r\n        self.process_command(msg.data, command_type=\'text\')\r\n\r\n    def process_command(self, command_text, command_type=\'voice\'):\r\n        """Process command using LLM cognitive planning"""\r\n        try:\r\n            # Generate cognitive plan using LLM\r\n            plan = self.generate_plan(command_text)\r\n\r\n            if plan:\r\n                # Publish the plan\r\n                plan_msg = String()\r\n                plan_msg.data = json.dumps(plan)\r\n                self.plan_pub.publish(plan_msg)\r\n\r\n                # Execute the plan\r\n                self.execute_plan(plan)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing command: {e}\')\r\n\r\n    def generate_plan(self, command_text):\r\n        """Generate cognitive plan using LLM"""\r\n        # Construct prompt for the LLM\r\n        prompt = f"""\r\n        You are a cognitive planner for a humanoid robot. Your task is to interpret the following command and create a detailed execution plan.\r\n\r\n        Command: "{command_text}"\r\n\r\n        The robot has the following capabilities:\r\n        - Navigation: Can move to specified locations\r\n        - Manipulation: Can pick up and place objects\r\n        - Perception: Can detect objects in the environment\r\n        - Interaction: Can respond to humans and perform social behaviors\r\n\r\n        Please provide a structured plan in JSON format with the following schema:\r\n        {{\r\n            "command": "original command",\r\n            "intent": "high-level intent",\r\n            "steps": [\r\n                {{\r\n                    "action": "action_type",\r\n                    "parameters": {{}},\r\n                    "description": "what this step does"\r\n                }}\r\n            ],\r\n            "objects": ["list of objects mentioned"],\r\n            "locations": ["list of locations mentioned"],\r\n            "confidence": float (0-1)\r\n        }}\r\n\r\n        Be specific about locations, objects, and actions. If the command is unclear, ask for clarification.\r\n        """\r\n\r\n        try:\r\n            # Call the LLM (this is a simplified example)\r\n            # In practice, you\'d use the appropriate API call for your LLM\r\n            response = self.call_llm(prompt)\r\n            plan = json.loads(response)\r\n            return plan\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error generating plan: {e}\')\r\n            return None\r\n\r\n    def call_llm(self, prompt):\r\n        """Call the LLM with the given prompt"""\r\n        # This is a placeholder - implement based on your chosen LLM provider\r\n        # For example, with OpenAI:\r\n        # response = openai.ChatCompletion.create(\r\n        #     model="gpt-3.5-turbo",\r\n        #     messages=[{"role": "user", "content": prompt}],\r\n        #     temperature=0.1\r\n        # )\r\n        # return response.choices[0].message.content\r\n\r\n        # For now, return a mock response for demonstration\r\n        return \'\'\'\r\n        {\r\n            "command": "Go to the kitchen and bring me a cup",\r\n            "intent": "fetch object from specific location",\r\n            "steps": [\r\n                {\r\n                    "action": "navigate",\r\n                    "parameters": {"location": "kitchen"},\r\n                    "description": "Navigate to the kitchen area"\r\n                },\r\n                {\r\n                    "action": "detect",\r\n                    "parameters": {"object": "cup"},\r\n                    "description": "Look for a cup in the environment"\r\n                },\r\n                {\r\n                    "action": "manipulate",\r\n                    "parameters": {"action": "pick", "object": "cup"},\r\n                    "description": "Pick up the detected cup"\r\n                },\r\n                {\r\n                    "action": "navigate",\r\n                    "parameters": {"location": "starting_position"},\r\n                    "description": "Return to the starting position"\r\n                },\r\n                {\r\n                    "action": "manipulate",\r\n                    "parameters": {"action": "place", "object": "cup"},\r\n                    "description": "Place the cup down"\r\n                }\r\n            ],\r\n            "objects": ["cup"],\r\n            "locations": ["kitchen", "starting_position"],\r\n            "confidence": 0.9\r\n        }\r\n        \'\'\'\n'})}),"\n",(0,i.jsx)(e.h2,{id:"83-cognitive-architecture-design",children:"8.3 Cognitive Architecture Design"}),"\n",(0,i.jsx)(e.h3,{id:"planning-hierarchy",children:"Planning Hierarchy"}),"\n",(0,i.jsx)(e.p,{children:"Cognitive planning typically follows a hierarchical structure:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task Level"}),": High-level goals and objectives"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Action Level"}),": Sequences of actions to achieve goals"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Motion Level"}),": Specific robot motions and configurations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Execution Level"}),": Low-level control commands"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"context-management",children:"Context Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class ContextManager:\r\n    def __init__(self):\r\n        self.current_task = None\r\n        self.task_history = []\r\n        self.environment_state = {}\r\n        self.robot_state = {}\r\n        self.user_preferences = {}\r\n\r\n    def update_environment_state(self, sensor_data):\r\n        """Update environment state based on sensor data"""\r\n        # Process sensor data and update environment model\r\n        pass\r\n\r\n    def get_context_prompt(self):\r\n        """Generate context for LLM queries"""\r\n        context = {\r\n            "environment": self.environment_state,\r\n            "robot": self.robot_state,\r\n            "task_history": self.task_history[-5:],  # Last 5 tasks\r\n            "current_task": self.current_task\r\n        }\r\n        return json.dumps(context, indent=2)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"plan-validation-and-safety",children:"Plan Validation and Safety"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class PlanValidator:\r\n    def __init__(self):\r\n        self.safety_rules = [\r\n            self.check_collision_risk,\r\n            self.check_physical_limits,\r\n            self.check_human_safety\r\n        ]\r\n\r\n    def validate_plan(self, plan):\r\n        """Validate plan for safety and feasibility"""\r\n        for rule in self.safety_rules:\r\n            if not rule(plan):\r\n                return False, f"Plan failed {rule.__name__} check"\r\n        return True, "Plan is valid"\r\n\r\n    def check_collision_risk(self, plan):\r\n        """Check if plan involves potential collisions"""\r\n        # Implement collision checking logic\r\n        return True\r\n\r\n    def check_physical_limits(self, plan):\r\n        """Check if plan respects robot physical limits"""\r\n        # Implement physical limit checking\r\n        return True\r\n\r\n    def check_human_safety(self, plan):\r\n        """Check if plan is safe around humans"""\r\n        # Implement human safety checking\r\n        return True\n'})}),"\n",(0,i.jsx)(e.h2,{id:"84-multi-step-task-planning",children:"8.4 Multi-Step Task Planning"}),"\n",(0,i.jsx)(e.h3,{id:"sequential-task-execution",children:"Sequential Task Execution"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class TaskExecutor:\r\n    def __init__(self, node):\r\n        self.node = node\r\n        self.current_plan = None\r\n        self.current_step = 0\r\n        self.execution_status = "idle"\r\n\r\n    def execute_plan(self, plan):\r\n        """Execute a multi-step plan"""\r\n        self.current_plan = plan\r\n        self.current_step = 0\r\n        self.execution_status = "executing"\r\n\r\n        while self.current_step < len(plan[\'steps\']) and self.execution_status == "executing":\r\n            step = plan[\'steps\'][self.current_step]\r\n\r\n            success = self.execute_step(step)\r\n\r\n            if success:\r\n                self.current_step += 1\r\n            else:\r\n                self.handle_failure(step)\r\n                break\r\n\r\n        self.execution_status = "completed" if self.current_step >= len(plan[\'steps\']) else "failed"\r\n\r\n    def execute_step(self, step):\r\n        """Execute a single step in the plan"""\r\n        action_type = step[\'action\']\r\n        parameters = step[\'parameters\']\r\n\r\n        self.node.get_logger().info(f\'Executing step: {step["description"]}\')\r\n\r\n        if action_type == \'navigate\':\r\n            return self.execute_navigation(parameters)\r\n        elif action_type == \'detect\':\r\n            return self.execute_detection(parameters)\r\n        elif action_type == \'manipulate\':\r\n            return self.execute_manipulation(parameters)\r\n        elif action_type == \'interact\':\r\n            return self.execute_interaction(parameters)\r\n        else:\r\n            self.node.get_logger().error(f\'Unknown action type: {action_type}\')\r\n            return False\r\n\r\n    def execute_navigation(self, params):\r\n        """Execute navigation step"""\r\n        # Create navigation goal\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose = self.get_pose_for_location(params[\'location\'])\r\n\r\n        # Send navigation goal\r\n        future = self.node.nav_client.call_async(goal_msg)\r\n\r\n        # Wait for result (with timeout)\r\n        rclpy.spin_until_future_complete(self.node, future, timeout_sec=30.0)\r\n\r\n        if future.result() is not None:\r\n            return future.result().result.success\r\n        else:\r\n            return False\r\n\r\n    def execute_manipulation(self, params):\r\n        """Execute manipulation step"""\r\n        # Create manipulation goal\r\n        goal_msg = ManipulationCommand.Goal()\r\n        goal_msg.action = params[\'action\']\r\n        if \'object\' in params:\r\n            goal_msg.object_name = params[\'object\']\r\n\r\n        # Send manipulation goal\r\n        future = self.node.manipulation_client.call_async(goal_msg)\r\n\r\n        # Wait for result (with timeout)\r\n        rclpy.spin_until_future_complete(self.node, future, timeout_sec=10.0)\r\n\r\n        if future.result() is not None:\r\n            return future.result().result.success\r\n        else:\r\n            return False\n'})}),"\n",(0,i.jsx)(e.h2,{id:"85-llm-prompt-engineering-for-robotics",children:"8.5 LLM Prompt Engineering for Robotics"}),"\n",(0,i.jsx)(e.h3,{id:"effective-prompting-strategies",children:"Effective Prompting Strategies"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class PromptEngineer:\r\n    def __init__(self):\r\n        self.system_prompt = """\r\n        You are a cognitive planning assistant for a humanoid robot. Your role is to:\r\n        1. Interpret natural language commands from humans\r\n        2. Create detailed, executable plans for the robot\r\n        3. Consider safety, feasibility, and efficiency\r\n        4. Ask for clarification when commands are ambiguous\r\n\r\n        Always respond in valid JSON format with the specified schema.\r\n        """\r\n\r\n    def create_planning_prompt(self, command, context):\r\n        """Create a prompt for cognitive planning"""\r\n        return f"""\r\n        {self.system_prompt}\r\n\r\n        CONTEXT:\r\n        {context}\r\n\r\n        COMMAND: {command}\r\n\r\n        Please provide a detailed plan in the following JSON format:\r\n        {{\r\n            "command": "{command}",\r\n            "intent": "high-level intent",\r\n            "steps": [\r\n                {{\r\n                    "action": "action_type",\r\n                    "parameters": {{}},\r\n                    "description": "what this step does",\r\n                    "expected_outcome": "what should happen after this step"\r\n                }}\r\n            ],\r\n            "objects": ["list", "of", "relevant", "objects"],\r\n            "locations": ["list", "of", "relevant", "locations"],\r\n            "confidence": 0.0-1.0,\r\n            "reasoning": "brief explanation of your plan"\r\n        }}\r\n\r\n        Requirements:\r\n        - Each step should be executable by the robot\r\n        - Include error handling where appropriate\r\n        - Consider the current state of the world\r\n        - Prioritize safety in all actions\r\n        """\r\n\r\n    def create_clarification_prompt(self, ambiguous_command, context):\r\n        """Create a prompt to ask for clarification"""\r\n        return f"""\r\n        {self.system_prompt}\r\n\r\n        CONTEXT:\r\n        {context}\r\n\r\n        AMBIGUOUS COMMAND: {ambiguous_command}\r\n\r\n        The command is ambiguous. Please ask specific questions to clarify:\r\n        1. Which specific object is meant?\r\n        2. Which specific location is meant?\r\n        3. What exactly should the robot do?\r\n\r\n        Respond with a list of specific questions to ask the user.\r\n        """\n'})}),"\n",(0,i.jsx)(e.h2,{id:"86-handling-uncertainty-and-adaptation",children:"8.6 Handling Uncertainty and Adaptation"}),"\n",(0,i.jsx)(e.h3,{id:"plan-adaptation-system",children:"Plan Adaptation System"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class PlanAdaptationSystem:\r\n    def __init__(self):\r\n        self.adaptation_strategies = {\r\n            \'object_not_found\': self.handle_object_not_found,\r\n            \'location_not_reachable\': self.handle_location_not_reachable,\r\n            \'action_failed\': self.handle_action_failed\r\n        }\r\n\r\n    def handle_failure(self, failed_step, error_type):\r\n        """Handle plan execution failure"""\r\n        if error_type in self.adaptation_strategies:\r\n            return self.adaptation_strategies[error_type](failed_step)\r\n        else:\r\n            return self.generic_failure_handling(failed_step)\r\n\r\n    def handle_object_not_found(self, step):\r\n        """Handle case where expected object is not found"""\r\n        # Ask LLM for alternative approaches\r\n        prompt = f"""\r\n        The robot was looking for {step[\'parameters\'].get(\'object\', \'an object\')}\r\n        but could not find it. What should the robot do next?\r\n\r\n        Possible alternatives:\r\n        1. Look in other locations\r\n        2. Ask user for help\r\n        3. Use a substitute object\r\n        4. Abort the task\r\n\r\n        Respond with a new plan step or a list of options.\r\n        """\r\n\r\n        # Call LLM for adaptation strategy\r\n        # Return new plan or continue with adaptation\r\n        pass\r\n\r\n    def handle_location_not_reachable(self, step):\r\n        """Handle case where navigation target is not reachable"""\r\n        # Implement navigation adaptation\r\n        pass\r\n\r\n    def handle_action_failed(self, step):\r\n        """Handle case where an action failed"""\r\n        # Implement action-specific adaptation\r\n        pass\n'})}),"\n",(0,i.jsx)(e.h2,{id:"87-integration-with-ros-2-ecosystem",children:"8.7 Integration with ROS 2 Ecosystem"}),"\n",(0,i.jsx)(e.h3,{id:"service-definitions",children:"Service Definitions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# cognitive_planning_interfaces/srv/GeneratePlan.srv\r\nstring command\r\nstring context\r\n---\r\nstring plan_json\r\nfloat64 confidence\r\nbool success\r\nstring error_message\r\n\r\n# cognitive_planning_interfaces/srv/ExecutePlan.srv\r\nstring plan_json\r\n---\r\nbool success\r\nstring status\r\nfloat64 execution_time\n"})}),"\n",(0,i.jsx)(e.h3,{id:"action-integration",children:"Action Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from rclpy.action import ActionClient\r\nfrom cognitive_planning_interfaces.action import ExecuteCognitivePlan\r\n\r\nclass LLMPlannerWithActions(LLMCognitivePlanner):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Create action client for plan execution\r\n        self.plan_execution_client = ActionClient(\r\n            self,\r\n            ExecuteCognitivePlan,\r\n            \'execute_cognitive_plan\'\r\n        )\r\n\r\n    def execute_plan_with_feedback(self, plan):\r\n        """Execute plan with progress feedback"""\r\n        goal_msg = ExecuteCognitivePlan.Goal()\r\n        goal_msg.plan_json = json.dumps(plan)\r\n        goal_msg.timeout = rclpy.Duration(seconds=300)  # 5 minute timeout\r\n\r\n        # Wait for action server\r\n        self.plan_execution_client.wait_for_server()\r\n\r\n        # Send goal and get feedback\r\n        future = self.plan_execution_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.plan_feedback_callback\r\n        )\r\n\r\n        future.add_done_callback(self.plan_complete_callback)\r\n\r\n    def plan_feedback_callback(self, feedback_msg):\r\n        """Handle plan execution feedback"""\r\n        self.get_logger().info(f\'Plan progress: {feedback_msg.feedback.progress}%\')\r\n\r\n    def plan_complete_callback(self, future):\r\n        """Handle plan completion"""\r\n        goal_handle = future.result()\r\n        result = goal_handle.get_result_async()\r\n        result.add_done_callback(self.plan_result_callback)\r\n\r\n    def plan_result_callback(self, future):\r\n        """Handle plan execution result"""\r\n        result_msg = future.result().result\r\n        self.get_logger().info(f\'Plan execution result: {result_msg.success}\')\n'})}),"\n",(0,i.jsx)(e.h2,{id:"88-practical-exercise-cognitive-planning-system",children:"8.8 Practical Exercise: Cognitive Planning System"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-objective",children:"Exercise Objective"}),"\n",(0,i.jsx)(e.p,{children:"Create a complete cognitive planning system that takes natural language commands and executes them on a simulated humanoid robot."}),"\n",(0,i.jsx)(e.h3,{id:"steps",children:"Steps"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Set up LLM integration with ROS 2"}),"\n",(0,i.jsx)(e.li,{children:"Implement context management system"}),"\n",(0,i.jsx)(e.li,{children:"Create plan validation and safety checks"}),"\n",(0,i.jsx)(e.li,{children:"Develop multi-step task execution"}),"\n",(0,i.jsx)(e.li,{children:"Add failure handling and adaptation"}),"\n",(0,i.jsx)(e.li,{children:"Test with various natural language commands"}),"\n",(0,i.jsx)(e.li,{children:"Validate safety and correctness"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"expected-results",children:"Expected Results"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Natural language command understanding (>80% accuracy)"}),"\n",(0,i.jsx)(e.li,{children:"Safe and correct plan execution"}),"\n",(0,i.jsx)(e.li,{children:"Proper failure handling and adaptation"}),"\n",(0,i.jsx)(e.li,{children:"Integration with ROS 2 messaging and services"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"LLM-based cognitive planning provides a powerful approach to bridge natural language commands with robotic action execution. By properly designing the cognitive architecture, implementing safety checks, and handling uncertainty, we can create intelligent humanoid robots capable of understanding and executing complex tasks through natural interaction."}),"\n",(0,i.jsx)(e.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cognitive Planning"}),": High-level planning using reasoning and knowledge"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Large Language Model (LLM)"}),": AI model for natural language understanding"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task Decomposition"}),": Breaking complex tasks into simpler steps"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Plan Validation"}),": Checking plans for safety and feasibility"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adaptation System"}),": Handling plan failures and unexpected situations"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://platform.openai.com/docs/",children:"OpenAI API Documentation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://arxiv.org/abs/2303.04650",children:"Robotics and AI Integration"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://arxiv.org/abs/2205.12258",children:"Natural Language to Robot Action"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://arxiv.org/abs/2103.06759",children:"Cognitive Architectures for Robotics"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);