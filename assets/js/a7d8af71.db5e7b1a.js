"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[3354],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var r=t(6540);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}},9375:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-robotic-nervous-system/mini-project","title":"Mini-Project: ROS 2 Control Stack","description":"This mini-project brings together all the concepts from Module 1 to build a complete ROS 2 control stack for a simulated humanoid robot. You\'ll implement a distributed system with multiple nodes that communicate to control the robot\'s movements.","source":"@site/docs/module-1-robotic-nervous-system/mini-project.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/mini-project","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/mini-project","draft":false,"unlisted":false,"editUrl":"https://github.com/humonide-book/ai-robotics-textbook/edit/main/docs/module-1-robotic-nervous-system/mini-project.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Mini-Project: ROS 2 Control Stack","sidebar_position":3},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Launch Files and Parameters","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-3"},"next":{"title":"Chapter 4: URDF Modeling for Humanoids","permalink":"/ai-robotics-textbook/docs/module-1-robotic-nervous-system/chapter-4"}}');var o=t(4848),i=t(8453);const s={sidebar_label:"Mini-Project: ROS 2 Control Stack",sidebar_position:3},l="Mini-Project: ROS 2 Control Stack",a={},c=[{value:"Project Overview",id:"project-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"1. Joint State Publisher Node",id:"1-joint-state-publisher-node",level:3},{value:"2. Trajectory Controller Node",id:"2-trajectory-controller-node",level:3},{value:"3. Command Interface Node",id:"3-command-interface-node",level:3},{value:"4. Feedback Monitor Node",id:"4-feedback-monitor-node",level:3},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Set Up Package Structure",id:"step-1-set-up-package-structure",level:3},{value:"Step 2: Implement Joint State Publisher",id:"step-2-implement-joint-state-publisher",level:3},{value:"Step 3: Implement Trajectory Controller",id:"step-3-implement-trajectory-controller",level:3},{value:"Step 4: Implement Command Interface",id:"step-4-implement-command-interface",level:3},{value:"Step 5: Create Setup File",id:"step-5-create-setup-file",level:3},{value:"Step 6: Create Launch File",id:"step-6-create-launch-file",level:3},{value:"Testing Your Implementation",id:"testing-your-implementation",level:2},{value:"Project Deliverables",id:"project-deliverables",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2},{value:"Extension Challenges",id:"extension-challenges",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"mini-project-ros-2-control-stack",children:"Mini-Project: ROS 2 Control Stack"})}),"\n",(0,o.jsx)(n.p,{children:"This mini-project brings together all the concepts from Module 1 to build a complete ROS 2 control stack for a simulated humanoid robot. You'll implement a distributed system with multiple nodes that communicate to control the robot's movements."}),"\n",(0,o.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,o.jsx)(n.p,{children:"Your task is to create a ROS 2 control stack that allows you to command a simulated humanoid robot to move its joints to specific positions. The system will include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A joint state publisher node"}),"\n",(0,o.jsx)(n.li,{children:"A trajectory controller node"}),"\n",(0,o.jsx)(n.li,{children:"A command interface node"}),"\n",(0,o.jsx)(n.li,{children:"A feedback monitoring node"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"Upon completion of this project, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Design and implement a complete ROS 2 control system"}),"\n",(0,o.jsx)(n.li,{children:"Integrate multiple nodes with different responsibilities"}),"\n",(0,o.jsx)(n.li,{children:"Use ROS 2 messages, services, and parameters effectively"}),"\n",(0,o.jsx)(n.li,{children:"Test and validate your control system in simulation"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,o.jsx)(n.p,{children:"The control stack will consist of the following nodes:"}),"\n",(0,o.jsx)(n.h3,{id:"1-joint-state-publisher-node",children:"1. Joint State Publisher Node"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Publishes current joint states using ",(0,o.jsx)(n.code,{children:"sensor_msgs/JointState"})," messages"]}),"\n",(0,o.jsx)(n.li,{children:"Simulates joint positions, velocities, and efforts"}),"\n",(0,o.jsxs)(n.li,{children:["Publishes robot description via ",(0,o.jsx)(n.code,{children:"/robot_description"})," parameter"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-trajectory-controller-node",children:"2. Trajectory Controller Node"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Subscribes to trajectory commands via ",(0,o.jsx)(n.code,{children:"trajectory_msgs/JointTrajectory"})," messages"]}),"\n",(0,o.jsx)(n.li,{children:"Implements simple joint interpolation"}),"\n",(0,o.jsx)(n.li,{children:"Publishes feedback on execution status"}),"\n",(0,o.jsx)(n.li,{children:"Uses services for configuration and control commands"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"3-command-interface-node",children:"3. Command Interface Node"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Provides a simple interface for sending trajectory commands"}),"\n",(0,o.jsx)(n.li,{children:"Subscribes to user commands (keyboard, GUI, or service calls)"}),"\n",(0,o.jsx)(n.li,{children:"Formats and sends trajectory messages to the controller"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"4-feedback-monitor-node",children:"4. Feedback Monitor Node"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Subscribes to joint states and controller feedback"}),"\n",(0,o.jsx)(n.li,{children:"Provides visualization of robot status"}),"\n",(0,o.jsx)(n.li,{children:"Logs execution metrics and errors"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,o.jsx)(n.h3,{id:"step-1-set-up-package-structure",children:"Step 1: Set Up Package Structure"}),"\n",(0,o.jsx)(n.p,{children:"Create a ROS 2 package for your control stack:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/humanoid_control_stack/src\r\ncd ~/ros2_ws/src/humanoid_control_stack\n"})}),"\n",(0,o.jsx)(n.p,{children:"Create the package.xml file:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\r\n<package format="3">\r\n  <name>humanoid_control_stack</name>\r\n  <version>0.0.1</version>\r\n  <description>ROS 2 Control Stack for Humanoid Robot</description>\r\n  <maintainer email="student@university.edu">Student</maintainer>\r\n  <license>MIT</license>\r\n\r\n  <depend>rclpy</depend>\r\n  <depend>std_msgs</depend>\r\n  <depend>sensor_msgs</depend>\r\n  <depend>trajectory_msgs</end>\r\n  <depend>builtin_interfaces</depend>\r\n\r\n  <exec_depend>python3-numpy</exec_depend>\r\n\r\n  <test_depend>ament_copyright</test_depend>\r\n  <test_depend>ament_flake8</test_depend>\r\n  <test_depend>ament_pep257</test_depend>\r\n  <test_depend>python3-pytest</test_depend>\r\n\r\n  <export>\r\n    <build_type>ament_python</build_type>\r\n  </export>\r\n</package>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"step-2-implement-joint-state-publisher",children:"Step 2: Implement Joint State Publisher"}),"\n",(0,o.jsxs)(n.p,{children:["Create ",(0,o.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/joint_state_publisher.py"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom builtin_interfaces.msg import Time\r\nimport numpy as np\r\nimport math\r\n\r\nclass JointStatePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_state_publisher')\r\n\r\n        # Publisher for joint states\r\n        self.joint_state_publisher = self.create_publisher(JointState, 'joint_states', 10)\r\n\r\n        # Timer for publishing joint states at 50Hz\r\n        self.timer = self.create_timer(0.02, self.publish_joint_states)\r\n\r\n        # Initialize joint positions (simulated humanoid)\r\n        self.joint_names = [\r\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\r\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\r\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\r\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\r\n            'head_pan_joint', 'head_tilt_joint'\r\n        ]\r\n\r\n        self.joint_positions = [0.0] * len(self.joint_names)\r\n        self.joint_velocities = [0.0] * len(self.joint_names)\r\n        self.joint_efforts = [0.0] * len(self.joint_names)\r\n\r\n        self.get_logger().info('Joint State Publisher initialized')\r\n\r\n    def publish_joint_states(self):\r\n        # Create joint state message\r\n        msg = JointState()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.name = self.joint_names\r\n        msg.position = self.joint_positions\r\n        msg.velocity = self.joint_velocities\r\n        msg.effort = self.joint_efforts\r\n\r\n        # Publish the message\r\n        self.joint_state_publisher.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = JointStatePublisher()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-3-implement-trajectory-controller",children:"Step 3: Implement Trajectory Controller"}),"\n",(0,o.jsxs)(n.p,{children:["Create ",(0,o.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/trajectory_controller.py"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom sensor_msgs.msg import JointState\r\nfrom builtin_interfaces.msg import Duration\r\nimport numpy as np\r\nfrom scipy.interpolate import interp1d\r\n\r\nclass TrajectoryController(Node):\r\n    def __init__(self):\r\n        super().__init__('trajectory_controller')\r\n\r\n        # Subscriber for trajectory commands\r\n        self.trajectory_sub = self.create_subscription(\r\n            JointTrajectory,\r\n            'joint_trajectory',\r\n            self.trajectory_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for joint commands (in a real system, this would go to hardware interface)\r\n        self.command_pub = self.create_publisher(JointState, 'joint_commands', 10)\r\n\r\n        # Publisher for controller status\r\n        self.status_pub = self.create_publisher(JointTrajectoryPoint, 'controller_status', 10)\r\n\r\n        # Current joint states (initially from simulation)\r\n        self.current_joint_states = None\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        # Controller state\r\n        self.active_trajectory = None\r\n        self.trajectory_start_time = None\r\n        self.current_point_idx = 0\r\n\r\n        # Timer for executing trajectories\r\n        self.timer = self.create_timer(0.01, self.execute_trajectory)  # 100Hz\r\n\r\n        self.get_logger().info('Trajectory Controller initialized')\r\n\r\n    def joint_state_callback(self, msg):\r\n        self.current_joint_states = msg\r\n\r\n    def trajectory_callback(self, msg):\r\n        self.get_logger().info(f'Received trajectory with {len(msg.points)} points')\r\n        self.active_trajectory = msg\r\n        self.trajectory_start_time = self.get_clock().now()\r\n        self.current_point_idx = 0\r\n\r\n    def execute_trajectory(self):\r\n        if self.active_trajectory is None or self.current_joint_states is None:\r\n            return\r\n\r\n        # Calculate elapsed time since trajectory started\r\n        current_time = self.get_clock().now()\r\n        elapsed = (current_time.nanoseconds - self.trajectory_start_time.nanoseconds) / 1e9\r\n\r\n        # Check if trajectory is complete\r\n        if self.current_point_idx >= len(self.active_trajectory.points):\r\n            self.active_trajectory = None\r\n            return\r\n\r\n        # Get the target point based on time\r\n        target_point = self.active_trajectory.points[self.current_point_idx]\r\n        target_time = target_point.time_from_start.sec + target_point.time_from_start.nanosec / 1e9\r\n\r\n        if elapsed >= target_time:\r\n            # Move to next point\r\n            self.current_point_idx += 1\r\n\r\n            if self.current_point_idx < len(self.active_trajectory.points):\r\n                # Publish the new target as a command\r\n                cmd_msg = JointState()\r\n                cmd_msg.header.stamp = self.get_clock().now().to_msg()\r\n                cmd_msg.name = self.active_trajectory.joint_names\r\n                cmd_msg.position = self.active_trajectory.points[self.current_point_idx-1].positions\r\n                cmd_msg.velocity = self.active_trajectory.points[self.current_point_idx-1].velocities\r\n                cmd_msg.effort = self.active_trajectory.points[self.current_point_idx-1].effort\r\n\r\n                self.command_pub.publish(cmd_msg)\r\n\r\n                # Publish status\r\n                status_msg = self.active_trajectory.points[self.current_point_idx-1]\r\n                self.status_pub.publish(status_msg)\r\n            else:\r\n                # Trajectory complete\r\n                self.active_trajectory = None\r\n                self.get_logger().info('Trajectory execution complete')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TrajectoryController()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-4-implement-command-interface",children:"Step 4: Implement Command Interface"}),"\n",(0,o.jsxs)(n.p,{children:["Create ",(0,o.jsx)(n.code,{children:"humanoid_control_stack/humanoid_control_stack/command_interface.py"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom builtin_interfaces.msg import Duration\r\nimport numpy as np\r\n\r\nclass CommandInterface(Node):\r\n    def __init__(self):\r\n        super().__init__('command_interface')\r\n\r\n        # Publisher for trajectory commands\r\n        self.trajectory_pub = self.create_publisher(JointTrajectory, 'joint_trajectory', 10)\r\n\r\n        # Timer to send a demonstration trajectory\r\n        self.timer = self.create_timer(5.0, self.send_demo_trajectory)\r\n\r\n        self.demo_count = 0\r\n\r\n        self.get_logger().info('Command Interface initialized')\r\n\r\n    def send_demo_trajectory(self):\r\n        msg = JointTrajectory()\r\n        msg.joint_names = [\r\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\r\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\r\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\r\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\r\n            'head_pan_joint', 'head_tilt_joint'\r\n        ]\r\n\r\n        # Create trajectory points\r\n        point1 = JointTrajectoryPoint()\r\n        point1.positions = [0.0] * len(msg.joint_names)  # Home position\r\n        point1.velocities = [0.0] * len(msg.joint_names)\r\n        point1.accelerations = [0.0] * len(msg.joint_names)\r\n        point1.time_from_start = Duration(sec=1, nanosec=0)\r\n\r\n        point2 = JointTrajectoryPoint()\r\n        # Simple movement: lift left arm\r\n        positions = [0.0] * len(msg.joint_names)\r\n        positions[6] = 0.5  # left_shoulder_joint\r\n        positions[7] = 0.3  # left_elbow_joint\r\n        point2.positions = positions\r\n        point2.velocities = [0.0] * len(msg.joint_names)\r\n        point2.accelerations = [0.0] * len(msg.joint_names)\r\n        point2.time_from_start = Duration(sec=2, nanosec=0)\r\n\r\n        point3 = JointTrajectoryPoint()\r\n        # Return to home position\r\n        point3.positions = [0.0] * len(msg.joint_names)\r\n        point3.velocities = [0.0] * len(msg.joint_names)\r\n        point3.accelerations = [0.0] * len(msg.joint_names)\r\n        point3.time_from_start = Duration(sec=3, nanosec=0)\r\n\r\n        msg.points = [point1, point2, point3]\r\n\r\n        self.trajectory_pub.publish(msg)\r\n        self.get_logger().info(f'Sent demo trajectory #{self.demo_count + 1}')\r\n        self.demo_count += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = CommandInterface()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-5-create-setup-file",children:"Step 5: Create Setup File"}),"\n",(0,o.jsxs)(n.p,{children:["Create ",(0,o.jsx)(n.code,{children:"humanoid_control_stack/setup.py"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\r\nimport os\r\nfrom glob import glob\r\n\r\npackage_name = 'humanoid_control_stack'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.1',\r\n    packages=[package_name],\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='Student',\r\n    maintainer_email='student@university.edu',\r\n    description='ROS 2 Control Stack for Humanoid Robot',\r\n    license='MIT',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'joint_state_publisher = humanoid_control_stack.joint_state_publisher:main',\r\n            'trajectory_controller = humanoid_control_stack.trajectory_controller:main',\r\n            'command_interface = humanoid_control_stack.command_interface:main',\r\n        ],\r\n    },\r\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-6-create-launch-file",children:"Step 6: Create Launch File"}),"\n",(0,o.jsxs)(n.p,{children:["Create ",(0,o.jsx)(n.code,{children:"humanoid_control_stack/launch/control_stack_launch.py"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='humanoid_control_stack',\r\n            executable='joint_state_publisher',\r\n            name='joint_state_publisher',\r\n            output='screen'\r\n        ),\r\n        Node(\r\n            package='humanoid_control_stack',\r\n            executable='trajectory_controller',\r\n            name='trajectory_controller',\r\n            output='screen'\r\n        ),\r\n        Node(\r\n            package='humanoid_control_stack',\r\n            executable='command_interface',\r\n            name='command_interface',\r\n            output='screen'\r\n        )\r\n    ])\n"})}),"\n",(0,o.jsx)(n.h2,{id:"testing-your-implementation",children:"Testing Your Implementation"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Build the package"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\r\ncolcon build --packages-select humanoid_control_stack\r\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Run the system"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 launch humanoid_control_stack control_stack_launch.py\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Monitor the system"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Check published joint states\r\nros2 topic echo /joint_states\r\n\r\n# Check controller status\r\nros2 topic echo /controller_status\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"project-deliverables",children:"Project Deliverables"}),"\n",(0,o.jsx)(n.p,{children:"Submit the following for evaluation:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Complete source code for all nodes"}),"\n",(0,o.jsx)(n.li,{children:"Launch file to start the entire system"}),"\n",(0,o.jsx)(n.li,{children:"A README.md file explaining your implementation"}),"\n",(0,o.jsx)(n.li,{children:"Screenshots or logs showing successful execution of the demonstration trajectory"}),"\n",(0,o.jsxs)(n.li,{children:["A brief report (1-2 pages) describing:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Design decisions made during implementation"}),"\n",(0,o.jsx)(n.li,{children:"Challenges encountered and how you addressed them"}),"\n",(0,o.jsx)(n.li,{children:"How your system follows ROS 2 best practices"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,o.jsx)(n.p,{children:"Your project will be evaluated on:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Functionality"})," (40%): Does the system correctly implement the required nodes and communication patterns?"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Code Quality"})," (25%): Is the code well-structured, documented, and following Python/ROS 2 best practices?"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Design"})," (20%): Does the architecture effectively separate concerns and follow ROS 2 principles?"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Testing"})," (15%): Does the implementation include proper error handling and validation?"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"extension-challenges",children:"Extension Challenges"}),"\n",(0,o.jsx)(n.p,{children:"For additional learning, consider implementing:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"PID Controllers"}),": Add PID controllers for more precise joint control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety Features"}),": Implement joint limits and collision avoidance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Advanced Trajectories"}),": Support for smooth, interpolated trajectories"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time Performance"}),": Optimize for real-time constraints"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"This mini-project demonstrates the practical application of ROS 2 concepts in creating a functional control system for a humanoid robot. You've implemented a distributed system with multiple nodes that communicate effectively to achieve a common goal."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(n.p,{children:"After completing this mini-project, you'll have a solid foundation in ROS 2 concepts and implementation. In Module 2, you'll integrate this control stack with simulation environments to test your robot in virtual worlds."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);